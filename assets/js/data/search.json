[
  
  {
    "title": "VSCode 다크 테마 간단 비교",
    "url": "/posts/2022-01-12-vscode-extensions-themes/",
    "categories": "development",
    "tags": "development, vscode, extension, theme",
    "date": "2022-01-12 00:00:00 +0800",
    





    "snippet": "가끔 편집기 테마가 질릴 때면 이것 저것 설치하고 지우기를 반복하지만, 시간이 지나면 자꾸 까먹고선 또 깔고 지우는 내 자신을 위해 쓰는 심심풀이 글. 참고로 나는 모든 디바이스를 다크 모드로 놓고 쓰고, 그렇지 않을 때도 (다크 모드라는게 없었을 때도) 무조건 편집기 테마는 어두운 테마를 고집하는 사람이기 때문에 라이트 테마 평가는 제외했다.GitHub Theme - Dark Dimmed (7 /10)  Name: GitHub Theme  Publisher: GitHub  VS Marketplace LinkGitHub 테마들..."
  },
  
  {
    "title": "react-router-dom 버전 6 이상에서 중첩된 라우팅 사용하는 방법",
    "url": "/posts/2022-01-11-react-router-dom-v6-nested-routes/",
    "categories": "react",
    "tags": "react, react-router-dom, router",
    "date": "2022-01-11 00:00:00 +0800",
    





    "snippet": "/* (하위 전체 경로 선택)을 사용하는 방법먼저 다음과 같이 라우터에서 부모 경로에 /* 부분을 추가해, 해당 라우트가 하위 라우트를 모두 포함하도록 만든다.function Router() {  return (    &amp;lt;BrowserRouter&amp;gt;      &amp;lt;Routes&amp;gt;        &amp;lt;Route path=&quot;/&quot; element={&amp;lt;Users /&amp;gt;} /&amp;gt;        &amp;lt;Route path=&quot;/..."
  },
  
  {
    "title": "react-router-dom 버전 6 이상 변경점 요약 정리",
    "url": "/posts/2022-01-10-update-react-router-dom/",
    "categories": "react",
    "tags": "react, router",
    "date": "2022-01-10 00:00:00 +0800",
    





    "snippet": "react-router-dom이 버전 5에서 6으로 업데이트 되면서 몇 가지 메이저 변경점이 생겼으며, 요약하면 다음과 같다. (추천 문서 : React Router Overview)Routes버전 6부터 Switch는 더이상 사용되지 않는다. 오피셜에 따라, Switch는 Routes라는 친구로 대체 되었다.exact버전 6부터 Routes가 알아서 최적의 경로를 배정 해주기 때문에, 기존에 Route에 사용했던 exact 속성을 더이상 사용하지 않게 되었다.*다수의 라우팅을 매칭하고 싶은 경우, 다음 코드 예제와 같이 UR..."
  },
  
  {
    "title": "React Router 주요 Hooks API 정리",
    "url": "/posts/2022-01-09-react-router-v6-hooks/",
    "categories": "react",
    "tags": "react, react-router, react-router-dom, react-router-native",
    "date": "2022-01-09 00:00:00 +0800",
    





    "snippet": "React Router에서 제공하는 Hooks API에 대한 요약 정리. 참고로 React Router는 react-router, react-router-dom, react-router-native 3개의 다른 패키지로 배포되고 있다.useParams  useParamsuseParams()는 현재 URL을 통해 파라미터를 가져올 때 사용하는 Hook이다.import { Routes, Route} from &#39;react-router-dom&#39;;function App() {  return (    &amp;lt;Rout..."
  },
  
  {
    "title": "React 타입스크립트 사용시 제네릭 지원 안하는 경우 대처법",
    "url": "/posts/2021-12-29-typescript-tip-react-router-v6-generic/",
    "categories": "react",
    "tags": "react, typescript",
    "date": "2021-12-29 00:00:00 +0800",
    





    "snippet": "실습할 때 흔히 사용하게 되는 useParams()와 같은 Hook들이 React Router 버전 업 (5.xx → 6.xx) 이후 제네릭을 지원하지 않아서, 최근 React + Typescript TIL 멘토링 그룹에서 가장 많이 올라오는 질문이다. 계속 React 공부를 하다보면 단순히 React Router만의 문제가 아닐 수 있어서 속성으로 작성해보는 글.우선 기존과 같은 방식 (버전 업 이전)의 일반적인 상황에서, useParams()에 제네릭으로 타입을 지정하려고 다음과 같은 interface를 작성했다고 가정해보..."
  },
  
  {
    "title": "React-Query 입문자를 위한 기본 사용법",
    "url": "/posts/2021-12-19-react-query/",
    "categories": "react",
    "tags": "react, react-query",
    "date": "2021-12-19 00:00:00 +0800",
    





    "snippet": "React-Query 영업 글.React-Query는 React에서 서버 사이드 상태를 편리하게 Fetching, Caching, Synchronizing, Updating 할 수 있도록 도와주는 라이브러리이다.기본 사용법React-Query가 좋은 이유 첫 번째는 단연코 사용하기 쉽다는 것이다.const queryClient = new QueryClient();function App() {  return (    &amp;lt;QueryClientProvider client={queryClient}&amp;gt;      &..."
  },
  
  {
    "title": "타입스크립트에서 styled-components 사용하기 (Theme, Props)",
    "url": "/posts/2021-11-30-styled-components-typescript-theme-props/",
    "categories": "react, css-in-js",
    "tags": "react, css-in-js, styled-components",
    "date": "2021-11-30 00:00:00 +0800",
    





    "snippet": "Props 타입 지정타입스크립트를 사용할 때 styled-components 컴포넌트에서 사용하는 Props를 체크하기 위해서는 다음과 같이 Props에 대한 interface를 작성한 뒤, styled.element&amp;lt;interface&amp;gt; 형식으로 Props 타입을 지정한다.interface IContainerProps {  bgColor: string;}const Container = styled.div&amp;lt;IContainerProps&amp;gt;`  background-color: ${(p..."
  },
  
  {
    "title": "styled-components 기본 사용법 요약 정리",
    "url": "/posts/2021-11-29-styled-components-usage/",
    "categories": "react, css-in-js",
    "tags": "react, css-in-js, styled-components",
    "date": "2021-11-29 00:00:00 +0800",
    





    "snippet": "멘토링 하면서 느낀점 푸념 한 줄 : 제발… styled-components 먼저 배우고 (잠깐이라도 보고) emotion 써주세요… 물론 그냥도 잘하는 친구들도 많지만, 가끔 잘못 이해하고 있는 (도대체 여태 어떻게 써온건지, 상상의 나래로 이해해서 틀렸지만 굴러가는 신기한 케이스들이 있음) 친구들 바로 잡아주려면 거의 처음부터 다시 해야 합니다… CSS 좀 하라고 그러면 ‘엥? 전 개발자 될건데요? 전 디자인 개뿔 시른대요?’ 하지 마시고 제발 CSS 배워주세요…어쨌든 그래서 적어보는 styled-components 입문자..."
  },
  
  {
    "title": "react-beautiful-dnd 기본 사용법 총정리",
    "url": "/posts/2021-11-16-react-beautiful-dnd/",
    "categories": "react",
    "tags": "react, react-beautiful-dnd",
    "date": "2021-11-16 00:00:00 +0800",
    





    "snippet": "react-beautiful-dnd는 React에서 Drag &amp;amp; Drop UI를 보다 쉽게 만들 수 있게 도와주는 라이브러로, 비슷한 라이브러리인 react-dnd나 react-draggable에 비해 비교적 단순한 UI 제작에 적합한 친구다.인기도는 NPM Trends를 기준으로 react-dnd와 비슷한 수준이며, 개인적으로 자유도는 react-dnd가 높고, 단순한 UI에 모던한 느낌 (애니메이션 기본 적용)을 주고 싶다면 react-beautiful-dnd가 훨씬 난이도는 낮은 것 같다. 만들고자하는 UI..."
  },
  
  {
    "title": "React Hook From 사용법 #2 에러 핸들링 응용",
    "url": "/posts/2021-11-08-react-hook-form-usage-2/",
    "categories": "react",
    "tags": "react, react-hook-form, hook, form",
    "date": "2021-11-08 00:00:00 +0800",
    





    "snippet": "본문은 React Hook From 사용법 #1 기초 활용과 이어지는 글이다.에러 메시지 추가formState.errors 객체를 통해 살펴보면, 에러가 발생할 때 해당 객체에 message라는 항목이 있는 것을 확인할 수 있는데, 이를 옵션을 추가하는 방식으로 간단하게 지정할 수 있다. 예를들어 required 필드는 true 또는 false 값을 가지지만, 여기에 텍스트를 작성하면 required를 만족하지 못했을 경우 (에러 발생시) 출력되는 에러 메시지가 된다.return (  &amp;lt;div&amp;gt;    ..."
  },
  
  {
    "title": "React Hook From 사용법 #1 기초 활용",
    "url": "/posts/2021-11-07-react-hook-form-usage-1/",
    "categories": "react",
    "tags": "react, react-hook-form, hook, form",
    "date": "2021-11-07 00:00:00 +0800",
    





    "snippet": "React Hook Form은 React에서 form을 보다 쉽게 다루기 위한 라이브러리이다. form을 핸들링 하기 위해 작성해야 하는 코드 중에는 일반적으로 중복되는 노가다가 많은데, React Hook Form을 사용한다면 이러한 단점을 보완할 수 있다.React Hook Form와 비슷한 라이브러리로는 Formik이라는 친구도 있다. NPM Trends를 기준으로 보자면 거의 비슷한 수준의 인지도를 가지고 있는데, 어느 것을 써도 비슷한 효과를 얻을 수 있으나, 내 경우 React Hook Form이 더 젊고, 업데이트..."
  },
  
  {
    "title": "VSCode better-comments 설정 파일 공유",
    "url": "/posts/2021-10-29-vscode-better-comments-setting/",
    "categories": "development",
    "tags": "development",
    "date": "2021-10-29 00:00:00 +0800",
    





    "snippet": "누가 공유해달래서 올리는 better-comments 설정. 사용법은 주석으로 달아 두었다. (settings.json 파일에 그대로 붙여 넣으면 됨!) 근데 사용하는 테마에 따라서 컬러는 교체 해야 할 듯 하다.{  &quot;better-comments.multilineComments&quot;: true,  &quot;better-comments.tags&quot;: [    {      // warn: warning      &quot;tag&quot;: &quot;warn&quot;,      &quot;color&q..."
  },
  
  {
    "title": "Recoil 기본 사용법 요약 정리",
    "url": "/posts/2021-10-15-recoil-usage/",
    "categories": "react",
    "tags": "react, recoil",
    "date": "2021-10-15 00:00:00 +0800",
    





    "snippet": "(오늘의 영업 대상) Recoil은 페이스북이 개발하고 관리하는 React 전용 상태 관리 라이브러리이다. 뭐 React의 아버지가 React 전용 상태 관리 라이브러리를 만들어 배포하고 관리하고 있으니 백그라운드는 든든한 편이고, 무엇보다도 배우고 사용하기가 매우 쉽다는 장점을 가지고 있다.인기도는 NPM Trends 결과를 기준으로 보자면 Zustand와 비슷한 수준. 아무래도 사용자 수로 따지자면 Redux, MobX에 비해 모자란건 (?) 사실이지만, 사용법이 매우 간단하고 직관적이라서 자주 애용하는 친구다.기본 사용법..."
  },
  
  {
    "title": "자바스크립트 객체를 순회하는 방법 (Object.keys 활용법)",
    "url": "/posts/2021-10-11-javascript-recursive-object-keys/",
    "categories": "javascript",
    "tags": "javascript",
    "date": "2021-10-11 00:00:00 +0800",
    





    "snippet": "다음과 같은 객체를 가정할 때, 내부 배열을 각각 순회하고자 하는 경우.const obj = {  a: [1, 2, 3],  b: [4, 5, 6],  c: [7, 8, 9],};먼저 객체의 키 값만 뽑아내기 위해서는 Object.keys()를 사용한다. 이때 결과 값은 키 값 (string)을 배열로 나타낸 것인데, 이를 사용해서 obj[key] 형태로 각각의 프로퍼티에 접근할 수 있게 된다. 이를 코드로 요약하자면 다음과 같다.Object.keys(obj); // [&#39;a&#39;, &#39;b&#39;, &#39;c..."
  },
  
  {
    "title": "[출판 소식] 자바스크립트 ES6+ 독학백서",
    "url": "/posts/2021-10-07-book-publish-javascript-for-beginners/",
    "categories": "notice",
    "tags": "notice, ebook, javascript",
    "date": "2021-10-07 00:00:00 +0800",
    





    "snippet": "제가 쓴 책 ≪자바스크립트 ES6+ 독학백서≫가 출판되어 소식 알립니다. 교보문고, 알라딘, 예스24, 밀리의서재, 구글플레이 등 다양한 유통사를 통해 구입하실 수 있으며, 현재는 eBook만 출간되어 판매 중 입니다. 또한 현재 모든 독학백서 시리즈 책이 종이책 추가 출간을 앞두고 있으며, 종이책으로 구매가 가능한 시점에 별도로 추가 공지 할 예정입니다. 많은 관심 부탁드립니다. 감사합니다."
  },
  
  {
    "title": "[강의 소식] 13가지 예제로 배우는 CSS Flex &amp; Grid 핵심 기능",
    "url": "/posts/2021-09-10-lecture-css-layout-for-beginners/",
    "categories": "notice",
    "tags": "notice, lecture, html, css",
    "date": "2021-09-10 00:00:00 +0800",
    





    "snippet": "13가지 예제로 배우는 CSS Flex &amp;amp; Grid 핵심 기능 강의 제작이 완료되어 소식 알립니다. 해당 강의는 인프런과 독점으로 계약하여 판매하기 때문에 인프런에서만 구매하실 수 있고, 9월 10일 부터 한 달간 얼리버드 20% 할인 이벤트를 진행 중이니 많은 관심 부탁드립니다.이번 강의는 CSS의 Flex와 Grid 기능을 사용해 레이아웃을 작성하는 방법을 13가지 실습 예제를 통해 학습할 수 있는 강의이며, HTML5 &amp;amp; CSS3 기초 문법 올인원 강의를 들으신 후, 바로 이어 수강하실 수 있..."
  },
  
  {
    "title": "[강의 소식] HTML &amp; CSS 기초 문법 올인원",
    "url": "/posts/2021-08-22-lecture-html-css-for-beginners/",
    "categories": "notice",
    "tags": "notice, lecture, html, css",
    "date": "2021-08-22 00:00:00 +0800",
    





    "snippet": "2021년 상반기 출간된 책 ≪HTML5 독학백서≫와 ≪CSS3 독학백서≫의 무료 강의인 HTML5 &amp;amp; CSS3 기초 문법 올인원 강의의 제작이 완료되어 소식 알립니다. 해당 강의는 전 범위 무료로 공개됩니다. (하단 링크 중 하나를 선택하셔서 들으시면 됩니다.) 감사합니다.  유튜브 개발자 이도해  인프런 개발자 이도해"
  },
  
  {
    "title": "React.memo에 대한 이해와 사용 방법",
    "url": "/posts/2021-08-12-react-memo/",
    "categories": "react",
    "tags": "react",
    "date": "2021-08-12 00:00:00 +0800",
    





    "snippet": "React.memo()는 불필요한 Re-Render를 방지하고, 애플리케이션의 성능을 최적화 해야 할 때 사용할 수 있는 HOC (고차 컴포넌트)다.언제 써야 할까?React.memo()를 사용하면 불필요한 Re-Render를 막아준다고 해서 모든 컴포넌트에 React.memo()를 쓰는 것은 옳지 않다. 오피셜 가이드에서도 React.memo()를 오직 성능 최적화만을 위해서 쓰라고 권고하고 있다.정리하자면, Re-Render 되지 않아도 되는 부분이 계속해서 (useState() 등으로 인해 서로 영향을 받아서) Re-Re..."
  },
  
  {
    "title": "React 부모 컴포넌트 값을 자식 컴포넌트에서 업데이트 해야 하는 경우",
    "url": "/posts/2021-07-03-react-update-datas-send-props-child-to-parent/",
    "categories": "react",
    "tags": "react, hook",
    "date": "2021-07-03 00:00:00 +0800",
    





    "snippet": "  부모 컴포넌트는 서버를 통해 최신 데이터베이스 정보를 패치 받는다.  해당 정보는 useState()를 사용해 부모 컴포넌트에서 관리한다. (정보가 업데이트되면 다시 그려질 수 있도록)  부모 컴포넌트는 해당 정보를 각각 하나씩 표현하기 위해 반복적으로 자식 컴포넌트를 생성하고, 자식 컴포넌트로 해당 정보를 보낸다.  이때 또 다른 자식 컴포넌트에서 해당 정보를 업데이트해야 할 경우. 정보가 업데이트 되었음을 자식 컴포넌트에서 부모 컴포넌트에 알릴 수 있어야 한다.이런 경우를 글로 설명하면 장황하지만, 생각보다 꽤 흔하게 ..."
  },
  
  {
    "title": "Mongoose 새로운 문서를 생성 및 저장한 다음에 Populate 하는 방법",
    "url": "/posts/2021-07-02-mongoose-populate-after-create-and-save/",
    "categories": "node, express, mongodb",
    "tags": "node, express, mongodb, mongoose",
    "date": "2021-07-02 00:00:00 +0800",
    





    "snippet": "newComment.populate(&quot;owner&quot;);이런 모습의 구문을 질문으로 받는 경우, 열에 아홉은 populate()가 (일반적으로 find() 등을 실행할 때 뒤에 붙이는 경우와는 달리) 실행되지 않았기 때문에 발생하는 문제이다. 근데 최근 이와 관련된 수업을 원격으로 진행하는데, 어떤 사람은 된다 그러고 어떤 사람은 안된다 그래서 굉장히 애를 먹었던 경험이 있다. 진도를 나가야해서 답변을 미루고 수업이 끝난 뒤 찾아보니 버전 차이에서 생기는 문제였다.Mongoose 버전 6 이전Mongoose 버전..."
  },
  
  {
    "title": "React 절대 경로 (또는 별칭) 사용하는 2가지 방법 (CRACO, WebPack)",
    "url": "/posts/2021-07-01-cra-absolute-route-craco-alias-webpack/",
    "categories": "react",
    "tags": "craco, webpack, react",
    "date": "2021-07-01 00:00:00 +0800",
    





    "snippet": "CRA 프로젝트먼저 CRA로 세팅한 경우에는 비교적 간단하게 해결할 수 있다. 자바스크립트 환경이라면 jsconfig.json 파일을, 타입스크립트 환경이라면 tsconfig.json 파일을 만들고 다음 코드를 추가한다.{  &quot;compilerOptions&quot;: {    &quot;baseUrl&quot;: &quot;src&quot;  },  &quot;includes&quot;: [&quot;src&quot;]}CRACO를 사용한 별칭 사용법만약 절대 경로가 아니라 별칭 (Alias)을 사용하고 싶다면 Web..."
  },
  
  {
    "title": "CSS 특정 비율을 가지는 이미지 만들기 (aspect-ratio · object-fit)",
    "url": "/posts/2021-06-25-css-aspect-ratio-object-fit/",
    "categories": "css",
    "tags": "css",
    "date": "2021-06-25 00:00:00 +0800",
    





    "snippet": "사용하는 기술  aspect-ratio  object-fit사용 예시예전처럼 비율에 따라서 padding을 잡아주고 어쩌고 이딴거 없음. 쏘 이지.&amp;lt;div class=&quot;container&quot;&amp;gt;  &amp;lt;img src=&quot;./img.jpg&quot; /&amp;gt;&amp;lt;/div&amp;gt;.container {  width: 300px;  aspect-ratio: 1 / 1;}img {  width: 100%;  height: auto;  object-fit: c..."
  },
  
  {
    "title": "내가 사용하는 React 애플리케이션 파일 구조",
    "url": "/posts/2021-06-22-react-application-file-structure/",
    "categories": "react, development",
    "tags": "react, convention",
    "date": "2021-06-22 00:00:00 +0800",
    





    "snippet": "일반적으로 선호되는 리액트 애플리케이션의 파일 구조는 파일 유형에 따라 분류하는 것이다. 파일 유형에 따라 분류한다는 것은, 비슷한 파일끼리 묶는 것을 의미한다. 이 방법은 자주 함께 사용되는 파일들을 함께 보관하는 Colocation (코로케이션) 원칙에 의해 컴포턴트는 컴포넌트끼리, 또 그 내부에서 구분되는 라우트나 컴포넌트의 묶음으로 분류될 수 있다.사실 파일 구조를 어떻게 잡느냐는 혼자 작업하는지, 협업하는지, 프리랜서인지, 직장을 다니는지 등에 따라 (일반적으로 회사에는 어느 정도 정해진 규정이 있기 때문에 이런 부분..."
  },
  
  {
    "title": "절대 주소와 상대 주소의 이해 (슬래시의 차이)",
    "url": "/posts/2021-06-21-web-absoulte-relative-path/",
    "categories": "web",
    "tags": "web, path, express, react",
    "date": "2021-06-21 00:00:00 +0800",
    





    "snippet": "path 형식 (상대 주소)의 경우 현재 파일 위치를 기준으로 경로를 지정한다.function Something() {    return (        &amp;lt;div&amp;gt;            &amp;lt;img src=&#39;img/sample.png&#39;&amp;gt;        &amp;lt;/div&amp;gt;    )}위와 같은 앞에 슬래시가 없는 img/sample.png 경로를 가정해보자. 이 경우 현재 디렉토리를 (클라이언트라면 클라이언트를) 기준으로 서브 디렉토리인 img 안에 있는 ..."
  },
  
  {
    "title": "React props.history.push(&#39;/&#39;)와 window.location.replace(&#39;/&#39;) 차이점",
    "url": "/posts/2021-06-17-react-props-history-push-window-location-replace/",
    "categories": "react",
    "tags": "react, router",
    "date": "2021-06-17 00:00:00 +0800",
    





    "snippet": "props.history.push(&#39;/&#39;)는 새로운 HTTP 요청을 생성하지 않는다. 반면에 window.location.replace()는 새로운 요청을 생성한다. i.g., window.location.replace() 또는 window.location.href을 사용할 경우 완전히 새로고침되고, 클라이언트 측에 상태는 초기화 된다.리액트에서 사용자를 다른 페이지로 이동시키기 위해서 일반적으로 props.history.push()를 사용한다. 이 history에는 사용자가 여태까지 타고온 경로가 스택처럼 다 ..."
  },
  
  {
    "title": "React 컴포넌트에서 location, history 등을 사용하기 위한 withRouter 사용법",
    "url": "/posts/2021-06-16-react-props-withrouter/",
    "categories": "react",
    "tags": "react, withrouter, react-router-dom",
    "date": "2021-06-16 00:00:00 +0800",
    





    "snippet": "withRouter란 라우트가 아닌 컴포넌트에서 location, history 등을 props로 전달받기 위해서 사용하는 HoC를 의미한다. 다음 코드 예제와 같이 사용한다.import React from &quot;react&quot;;import { withRouter } from &quot;react-router-dom&quot;;const Something = withRouter((props) =&amp;gt; {  /* ... */});export default Something();e.g., React Styled..."
  },
  
  {
    "title": "react-flash-message 에러 (Module not found) 해결 방법",
    "url": "/posts/2021-06-15-react-flash-message-error/",
    "categories": "react",
    "tags": "react, error, react-flash-message",
    "date": "2021-06-15 00:00:00 +0800",
    





    "snippet": "Module not found: Can&#39;t resolve &#39;react-flash-message&#39;다음 명령어로 해결할 수 있다.yarn add https://github.com/Looskie/react-flash-message.git가끔가다 쓰는 건데, 사용법이 단순해서 한 번도 문제가 없었다가 갑자기 모듈을 찾을 수 없다고 난리여서 30분을 허비했다. 등잔 밑이 어둡다고 공식 레포 이슈에 벌써 같은 문제를 겪는 사람이 이슈를 발행했고, 코멘트 중에 해결책을 공유해준 사람이 있어서 해결할 수 있었다."
  },
  
  {
    "title": "React CORS 문제 해결을 위한 Proxy 서버 설정 방법 (Access-Control-Allow-Origin 에러)",
    "url": "/posts/2021-06-14-react-cors-proxy-error/",
    "categories": "react",
    "tags": "react, cors, proxy, error",
    "date": "2021-06-14 00:00:00 +0800",
    





    "snippet": "Access to XMLHttpRequest at &#39;http://localhost:4000&#39; from origin &#39;http://localhost:3000&#39; has been blocked by CORS policy: Response to preflight request doesn&#39;t pass access control check: No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource.packag..."
  },
  
  {
    "title": "CRACO를 사용한 Emotion 사용 설정 방법 (@jsx 선언 제거)",
    "url": "/posts/2021-06-13-craco-emotion-react/",
    "categories": "css-in-js",
    "tags": "css-in-js, emotion, craco, react",
    "date": "2021-06-13 00:00:00 +0800",
    





    "snippet": "CRA로 세팅한 리액트 프로젝트에서 Emotion (@emotion/react)을 사용하기 위해서는 다음과 같이 매번 @jsx 관련 선언을 명시하는 과정이 필요하다. 이 과정을 생략하기 위해서는 Babel 설정이 필요한데, CRA는 Babel의 사용자 설정을 막아두었기 때문에 eject를 사용해야 이 부분을 설정할 수 있다. (한 번 eject한 프로젝트는 이전 상태로 되돌아 갈 수 없다.)Create React App Configuration Override의 약자인 CRACO를 사용하면 eject 하지 않고도 리액트 애플리..."
  },
  
  {
    "title": "Session 인증 방식과 JWT 인증 방식의 비교",
    "url": "/posts/2021-06-12-express-way-auth-user/",
    "categories": "web",
    "tags": "authentication, session, cookie, jwt",
    "date": "2021-06-12 00:00:00 +0800",
    





    "snippet": "  참고 : Cookie · Session 기술의 이해Session 인증 방식HTTP 웹 서버는 Stateless 프로토콜을 사용하기 때문에, 사용자의 인가 사실을 유지할 수 없고, 매번 다른 페이지로 이동하거나 새로고침을 할 때 다시 인가 됨을 증명해야만 한다. 이때 사용할 수 있는 방법 중 하나가 이 Session (이하 세션) 기반 인증 방식이며, 사용자가 웹 서버에 접속해 있는 상태를 하나의 세션으로 구분한다.세션과 함께 사용되는 웹 기술 중 Cookie (이하 쿠키)는 상태 정보를 유지하기 위해 사이트 단위를 기준으로..."
  },
  
  {
    "title": "Mongoose Schema.pre 함수 사용시 this 바인딩 문제",
    "url": "/posts/2021-06-11-mongoose-schema-pre-arrow-function-this-error/",
    "categories": "node, express, mongodb",
    "tags": "node, express, mongodb, mongoose",
    "date": "2021-06-11 00:00:00 +0800",
    





    "snippet": "다음과 같이 화살표 함수를 사용할 경우, this가 상위 스코프를 가리키기 때문에 의도한대로 ‘객체 자체’에 바인딩이 안되는 문제가 발생한다.userSchema.pre(&quot;save&quot;, () =&amp;gt; {  /* ... */});따라서 다음과 같이 function 키워드를 사용해 함수를 만들어야 한다.userSchema.pre(&quot;save&quot;, function () {  /* ... */});또는function hashingPassword() {  /* ... */}userSchema.pre..."
  },
  
  {
    "title": "Yarn Workspace 기본 사용법",
    "url": "/posts/2021-06-11-yarn-worksapce/",
    "categories": "development",
    "tags": "development, yarn, workspce",
    "date": "2021-06-11 00:00:00 +0800",
    





    "snippet": "sudo npm install -g yarn # yarn 없는 경우 설치project라는 폴더 안에 client (리액트 등)와 server (Express 등)라는 폴더가 있다고 가정할 때, project 위치에서 다음 명령어로 package.json 파일을 생성한다.yarn init -yproject 루트 위치에 생성된 package.json 파일에 다음 내용을 추가한다.{  &quot;private&quot;: true,  &quot;workspcaes&quot;: [&quot;client&quot;, &quot;serv..."
  },
  
  {
    "title": "GraphQL를 위한 Apollo Client 기본 사용법",
    "url": "/posts/2021-06-09-graphql-apollo-client/",
    "categories": "apollo, graphql",
    "tags": "apollo, graphql",
    "date": "2021-06-09 00:00:00 +0800",
    





    "snippet": "Apollo 세팅리액트 환경에서 GraphQL을 사용하기 위해서 Apollo를 사용할 수 있다. 다음 명령어를 사용해 리액트 프로젝트를 구성하고 필요한 패키지를 설치한다.npx create-react-app projectcd projectnpm install @apollo/client graphql선택적으로 Apollo Client Devtools를 사용할 수도 있다.ApolloClient 작성요청을 보낼 때 마다 특정 URL을 작성해야 하는 REST API와 다르게, GraphQL에 요청을 보내기 위해서 (Apollo Cli..."
  },
  
  {
    "title": "GraphQL Query · Mutation 차이점",
    "url": "/posts/2021-06-05-graphql-query-mutation/",
    "categories": "graphql",
    "tags": "graphql",
    "date": "2021-06-05 00:00:00 +0800",
    





    "snippet": "QueryQuery는 객체에 대한 특정 필드를 요청하는 행위를 말한다. i.g., SELECT문에 사용되는 것이며, REST API에서 GET 요청을 보내는 것과 같다.const hello = {  title: &quot;hello movie&quot;,  genres: [&quot;action&quot;, &quot;drama&quot;],};const resolvers = {  Query: {    post: () =&amp;gt; hello,  },};Resolver가 위와 같을 때, hello의 title은 다음과 같이..."
  },
  
  {
    "title": "GraphQL 서버 기본 사용법 (graphql-yoga 사용)",
    "url": "/posts/2021-06-04-graphql-server/",
    "categories": "graphql",
    "tags": "graphql, backend",
    "date": "2021-06-04 00:00:00 +0800",
    





    "snippet": "graphql-yoga를 사용하면 리액트 프로젝트를 생성할 때와 같이 간단하게 GraphQL 프로젝트를 시작할 수 있다.npm init -ynpm install graphql-yoga이때 편리한 서버 테스트를 위해서 선택적으로 nodemon을 적용하거나, Node 환경에서 ES6+ 문법을 사용하기 위해서 Babel을 적용할 수 있다.// sudo npm install -g nodemonnpm install @babel/core @babel/node @babel/preset-env -Dpackage.json에 실행을 위한 스크립..."
  },
  
  {
    "title": "React Redux 기본 사용법",
    "url": "/posts/2021-06-03-react-js-reudx/",
    "categories": "redux, react",
    "tags": "redux, react, javascript",
    "date": "2021-06-03 00:00:00 +0800",
    





    "snippet": "리액트에서 리덕스를 사용하기 위해서 다음과 같은 라이브러리를 설치한다.npm install redux react-reduxcreateStore()와 reducer()를 작성한다.export const ACTIONS = {  ADD: &quot;ADD&quot;,  DELETE: &quot;DELETE&quot;,};function reducer(todos = [], { type, text, id }) {  switch (type) {    case ACTIONS.ADD:      return [{ id: uuid(), text..."
  },
  
  {
    "title": "GraphQL이란? REST API와의 비교",
    "url": "/posts/2021-06-03-graphql-rest-api/",
    "categories": "graphql",
    "tags": "graphql, rest",
    "date": "2021-06-03 00:00:00 +0800",
    





    "snippet": "GraphQLGraphQL은 쿼리 언어이자 애플리케이션 프로그래밍 인터페이스(API)를 위한 서버측 런타임으로, 클라이언트에게 요청한 만큼의 데이터를 제공하는 역할을 하며, REST API를 대체할 수 있다. i.g., 클라이언트는 GraphQL과 대화하고, GraphQL은 다른 API와 대화할 수 있다.REST API vs. GraphQL백엔드에 구축된 REST API를 사용하는 (데이터를 REST API에 요청하는) 경우, 필요하지 않은 정보들까지 받아야 하는 Over Fetching 문제나, 데이터가 나눠져 있어서 여러 ..."
  },
  
  {
    "title": "Node Redux 기본 사용법",
    "url": "/posts/2021-06-02-node-js-reudx/",
    "categories": "redux, node",
    "tags": "redux, node, javascript",
    "date": "2021-06-02 00:00:00 +0800",
    





    "snippet": "기본 사용법리덕스는 데이터 (state 값, 애플리케이션에서 변하는 값)를 한 곳에서 관리하기 위해 사용한다.npm install reduxcreateStore()데이터를 관리하기 위한 저장소는 보통 Store라 부르며, createStore() 함수를 사용해 생성한다. 이렇게 생성된 store는 dispatch(), subscribe(), getState(), replaceReducer() 함수를 가진다.import { createStore } from &quot;redux&quot;;const store = createSt..."
  },
  
  {
    "title": "React Context API + Hooks와 Redux 사용법 비교",
    "url": "/posts/2021-06-01-react-redux-context-hooks/",
    "categories": "redux, react",
    "tags": "react, hook, context, redux",
    "date": "2021-06-01 00:00:00 +0800",
    





    "snippet": "Context API + HooksContext API는 상태 값을 공유하기 위해 사용하고, Hooks는 함수형 컴포넌트에서 상태 값을 사용하기 위해 사용한다. 이 두 가지 기능을 사용해서 상태를 관리하는 간단한 카운터 예제는 다음과 같다.store 생성import React, { createContext } from &quot;react&quot;;const Context = createContext(&quot;&quot;);export default context;공유할 값을 제공function App() {  const ..."
  },
  
  {
    "title": "타입스크립트 세 가지 타입 가드 방법",
    "url": "/posts/2021-05-24-typescript-type-guard/",
    "categories": "typescript",
    "tags": "typescript",
    "date": "2021-05-24 00:00:00 +0800",
    





    "snippet": "typeof를 사용한 타입 가드function printMessage(message: string | number) {  if (typeof message === &quot;string&quot;) {    console.log(message.length);  }  /* ... */}in을 사용한 타입 가드interface A {  name: string;  /* ... */}interface B {  email: string;  /* ... */}function printMessage(message: A | B) {  if ..."
  },
  
  {
    "title": "타입스크립트 타입 단언의 이해",
    "url": "/posts/2021-05-23-typescript-type-assertion/",
    "categories": "typescript",
    "tags": "typescript",
    "date": "2021-05-23 00:00:00 +0800",
    





    "snippet": "다음과 같이 DOM API를 조작하고자 할 때, header에 추론된 타입은 HTMLDivElement | null이기 때문에 라인 2에서 에러가 발생한다.const header = document.querySelector(&quot;div&quot;);header.innerText = &quot;Hello&quot;;이 경우 다음과 같이 header가 HTMLDivElement 타입이라는 것을 단언함으로써 문제를 해결할 수 있다.const header = document.querySelector(&quot;div&quot;)..."
  },
  
  {
    "title": "타입스크립트를 사용하기 위한 WebPack + ESLint 설정 방법",
    "url": "/posts/2021-05-21-typescript-settup-webpack-ts-loader/",
    "categories": "webpack, typescript, eslint",
    "tags": "typescript, webpack, eslint, prettier",
    "date": "2021-05-21 00:00:00 +0800",
    





    "snippet": "우선 다음과 같이 프로젝트를 세팅하고 필요한 의존성을 설치한다.npm init -ynpm install eslint @typescript-eslint/eslint-plugin @typescript-eslint/parser -Dnpm install typescript ts-loader webpack webpack-cli webpack-dev-server -Dpackage.jsonscript 항목을 적절히 추가한다.{  &quot;script&quot;: {    &quot;build&quot;: &quot;webpack --mo..."
  },
  
  {
    "title": "타입스크립트 세 가지 제네릭 타입 제한 방법",
    "url": "/posts/2021-05-21-typescript-limited-generic-type/",
    "categories": "typescript",
    "tags": "typescript",
    "date": "2021-05-21 00:00:00 +0800",
    





    "snippet": "조건부 타입 설정interface A {  /* ... */}interface B {  /* ... */}function a&amp;lt;T extends A ? A : B&amp;gt;(message: T): void {}특정 메소드를 가진 타입만 허용다음 함수는 length 메소드를 가지고 있는 타입만을 허용한다.function a&amp;lt;T extends { length: number }&amp;gt;(message: T): void {}특정 객체의 키 값만을 허용다음 함수에서 허용하는 타입은 obj의 키 값인 &#..."
  },
  
  {
    "title": "webpack-dev-server 사용시 발생할 수 있는 config-yargs 에러 해결 방법",
    "url": "/posts/2021-05-20-webpack-cli-config-yargs-error/",
    "categories": "webpack",
    "tags": "webpack, error",
    "date": "2021-05-20 00:00:00 +0800",
    





    "snippet": "Error: Cannot find module &#39;webpack-cli/bin/config-yargs&#39;멘티가 혼자 고쳐보려고 했는데, 검색해보니 사용하는 webpack, webpack-cli 버전과 webpack-dev-server의 버전이 충돌해 생기는 에러라고 webpack의 버전을 바꾸라는 말뿐이어서 이래저래 해봐도 안된다고 울면서 가져왔다 ㅋㅋㅋㅋㅋㅋㅋ 뭐 예전에는 버전이 안맞아서 에러가 생겼을 수도 있긴한데… 하여튼 WebPack이 버전 5로 올라가면서 명령어가 webpack-dev-server가 아니라 ..."
  },
  
  {
    "title": "타입스크립트 유니온 타입과 인터섹션 타입",
    "url": "/posts/2021-05-19-typescript-union-intersection-type/",
    "categories": "typescript",
    "tags": "typescript",
    "date": "2021-05-19 00:00:00 +0800",
    





    "snippet": "유니온 타입 (Union Type)유니온 타입은 | 연산자를 사용해서 여러 개의 타입 중 하나에 해당하는 타입을 의미한다.const print = (message: string | number): void =&amp;gt; console.log(message);위 코드 예제에서 message는 string 타입이거나 number 타입일 수 있다.인터페이스에 유니온 타입 적용interface A {  name: string;  email: string;}interface B {  name: string;  phone: numbe..."
  },
  
  {
    "title": "타입스크립트 타입 별칭과 인터페이스의 차이점",
    "url": "/posts/2021-05-18-typesctip-type-ailas-interface/",
    "categories": "typescript",
    "tags": "typescript",
    "date": "2021-05-18 00:00:00 +0800",
    





    "snippet": "타입 별칭 (Type Ailas)타입 별칭은 임의의 타입 또는 인터페이스를 참조할 수 있는 타입 변수를 의미하며, type이라는 키워드를 사용해 다음과 같이 생성할 수 있다.type User = {  id: number;  name: string;  email: string;  password: string;};let user: User;타입 별칭은 제네릭, 함수 등에도 사용할 수 있다. (i.g., 타입을 사용하는 곳에는 모두 타입 별칭을 대신 사용할 수 있다.)인터페이스 (Interface)인터페이스는 interface 키..."
  },
  
  {
    "title": "VS Code ESLint 동작하지 않는 (반응이 없는) 경우 해결 방법",
    "url": "/posts/2021-05-06-eslint-working-directory-setting/",
    "categories": "eslint",
    "tags": "eslint, vscode",
    "date": "2021-05-06 00:00:00 +0800",
    





    "snippet": "VS Code에서 ESLint 확장도 설치되어 있고, 프로젝트에 .eslintrc 파일도 작성되어 있으며, npm install 실행시 별다른 에러도 발생하지 않지만, 결과적으로 ESLint가 동작하지 않는 경우. (e.g., 타입을 생략해도 밑줄이 뜨지 않는 경우.)ESLint의 설정 오류나 .eslintrc 파일 작성에 문제가 있을 수도 있지만, 일반적으로 아무런 오류도 발생하지 않으면서 동작을 하지 않는 경우는 대게 eslint 버전 호환 문제이다. 프로젝트에서 사용하는 eslint의 버전을 다운그레이드 하거나, sett..."
  },
  
  {
    "title": "tsconfig.json 설정 파일 작성 방법",
    "url": "/posts/2021-05-03-tsconfig-options/",
    "categories": "development, typescript",
    "tags": "development, typescript, tsconfig",
    "date": "2021-05-03 00:00:00 +0800",
    





    "snippet": "TSConfig Referencefiles프로그램에 포함할 파일의 허용 목록 (Allowlist)을 정의하며, 파일을 찾을 수 없을 경우 에러가 발생한다. 일반적으로 포함할 파일의 개수가 적을 때 사용된다.{  &quot;files&quot;: [&quot;home.ts&quot;, &quot;about.ts&quot;, &quot;contact.ts&quot;]}include프로그램에 포함할 파일 이름 또는 하위 폴더를 포함하는 경로를 지정할 때 사용하며, 포함할 파일의 개수가 많거나, 여기 저기 흩어져 있을 경우에 사용된다..."
  },
  
  {
    "title": "React ESLint react-hooks/rules-of-hooks 에러 해결 방법",
    "url": "/posts/2021-05-02-react-hooks-rules-of-hooks-error/",
    "categories": "eslint, react",
    "tags": "react, eslint, hook, error",
    "date": "2021-05-02 00:00:00 +0800",
    





    "snippet": "ESLint에서 react-hooks (airbnb-hooks 등)를 사용할 때 발생할 수 있는 에러로, 자바스크립트의 일반 함수에서 Hook을 호출하지 말라는 에러이다. 이 에러를 해결하기 위해서는 다음 두 가지 방식으로 Hook을 호출해야 한다.  React 함수형 컴포넌트에서 호출  Custom Hook에서 호출.eslintrc 파일에서 다음 항목으로 설정할 수 있다.&quot;rules&quot;: {    &quot;react-hooks/rules-of-hooks&quot;: &quot;error&quot;}Hook을..."
  },
  
  {
    "title": "ESLint no-case-declarations 에러 해결 방법",
    "url": "/posts/2021-05-01-eslint-no-case-declarations/",
    "categories": "eslint",
    "tags": "eslint, error",
    "date": "2021-05-01 00:00:00 +0800",
    





    "snippet": "ESLint (no-case-declarations)Disallow lexical declarations in case/default clauses (no-case-declarations)위와 같은 no-case-declarations 에러는 다음과 같이 case문 내에서 변수나 상수 또는 함수 등이 제한된 스코프가 없이 선언되는 것을 허용하지 않는다는 것을 알리는 에러이다.switch (foo) {  case 1:    let x = 1;    break;  case 2:    const y = 2;    break;  ca..."
  },
  
  {
    "title": "Webpack SASS (SCSS) 사용법",
    "url": "/posts/2021-04-05-scss-css-loader/",
    "categories": "webpack",
    "tags": "webpack, javascript, scss",
    "date": "2021-04-05 00:00:00 +0800",
    





    "snippet": "설치npm install sass -Dnpm install sass-loader -Dnpm install css-loader -Dnpm install mini-css-extract-plugin -D각각의 라이브러리가 하는 역할은 다음과 같다.  sass-loader : SCSS 파일을 CSS 파일로 변환  css-loader : CSS 파일을 읽음  mini-css-extract-plugin : 한 파일로 묶음설정const miniCssExtractPlugin = require(&quot;mini-css-extract-plug..."
  },
  
  {
    "title": "Webpack 여러 개의 Entry Point 지정하기",
    "url": "/posts/2021-04-04-entry-file-name/",
    "categories": "webpack",
    "tags": "webpack, javascript",
    "date": "2021-04-04 00:00:00 +0800",
    





    "snippet": "module.exports = {  entry: {    // 다수의 엔트리 포인트 지정    main: &quot;./src/client/js/main.js&quot;,    something: &quot;./src/client/js/something.js&quot;,  },  mode: &quot;development&quot;,  watch: true,  output: {    // 각각을 이름 [name] (변수)으로 저장    filename: &quot;js/[name].js&quot;,    path: path.r..."
  },
  
  {
    "title": "Webpack Babel-Loader 사용법",
    "url": "/posts/2021-04-03-babel-loader/",
    "categories": "webpack",
    "tags": "webpack, javascript, babel",
    "date": "2021-04-03 00:00:00 +0800",
    





    "snippet": "npm install babel-loader -D{    test: /\\.js$/,    use: {        loader: &quot;babel-loader&quot;,        options: {            presets: [                [&quot;@babel/preset-env&quot;, { targets: &quot;defaults&quot; }],            ],        },    },}"
  },
  
  {
    "title": "Webpack 기본 사용법",
    "url": "/posts/2021-04-02-webpack-config/",
    "categories": "webpack",
    "tags": "webpack, javascript",
    "date": "2021-04-02 00:00:00 +0800",
    





    "snippet": "설치npm install webpack webpack-cli -D속성  entry  output  module  pluginentryentry 속성에는 웹팩이 모듈 번들링을 하기 위한 진입점이자 변환하고자 하는 자바스크립트 파일의 경로를 작성한다.module.exports = {  entry: &quot;src/index.js&quot;,};위 코드 예시와 같은 entry 속성을 정의하면 src 폴더에 위치한 index.js 파일을 진입점으로 빌드하게 된다.module.exports = {  entry: {    home: &..."
  },
  
  {
    "title": "Webpack이란?",
    "url": "/posts/2021-04-01-what-is-webpack/",
    "categories": "webpack",
    "tags": "webpack, gulp, javascript",
    "date": "2021-04-01 00:00:00 +0800",
    





    "snippet": "WebPack은 자바스크립트 애플리케이션의 정적 모듈 번들러 (Static Module Bundler)로, 규모가 있는 시스템에 존재할 수 있는 많은 자바스크립트 파일들을 하나의 파일로 관리하기 위해 사용된다.Module이란?  애플리케이션을 구성하는 자원들  HTML, CSS, 자바스크립트 파일들 등Bundle이란?  소프트웨어 및 일부 하드웨어와 함께 작동하는 데 필요한 모든 것을 포함하는 패키지  각각의 모듈들에 대해 의존성 관계를 파악한 하나 또는 여러 개의 그룹Module Bundler란?대부분의 프로그래밍 언어에서는..."
  },
  
  {
    "title": "[출판 소식] CSS3 독학백서",
    "url": "/posts/2021-03-25-book-publish-css3-for-beginners/",
    "categories": "notice",
    "tags": "notice, ebook, css",
    "date": "2021-03-25 00:00:00 +0800",
    





    "snippet": "제가 쓴 책 ≪CSS3 독학백서≫이 출판되어 소식 알립니다. 교보문고, 알라딘, 예스24, 밀리의서재, 구글플레이 등 다양한 유통사를 통해 구입하실 수 있으며, 현재는 eBook만 출간되어 판매 중 입니다. 많은 관심 부탁드립니다. 감사합니다.  HTML &amp;amp; CSS 무료 강의 바로가기  CSS Flex &amp;amp; Grid 강의 바로가기"
  },
  
  {
    "title": "Heroku code=H10 desc=&#39;App crashed&#39; 에러 해결 방법",
    "url": "/posts/2021-03-03-heroku-port/",
    "categories": "node, express, service",
    "tags": "node, express, heroku",
    "date": "2021-03-03 00:00:00 +0800",
    





    "snippet": "const PORT = process.env.PORT || 4000;app.listen(PORT, listenServer);Heroku에서는 필요에 따라 자동으로 포트 넘버를 (유동적으로) 설정하기 때문에 환경 변수 설정이 필요하다. process.env.PORT는 Heroku에서만 동작하며, (오로지 Heroku를 위한) Heroku를 사용하지 않을 때에는 설정한 포트로 열리도록 위 코드와 같이 설정한다."
  },
  
  {
    "title": "Heroku MongoDB 환경 변수 등록하기",
    "url": "/posts/2021-03-02-heroku-mongodb/",
    "categories": "service",
    "tags": "node, heroku, mongodb",
    "date": "2021-03-02 00:00:00 +0800",
    





    "snippet": "선행 조건  Heroku 가입  Heroku 앱 생성  MongoDB Atlas 가입  Organization, Project, Cluster 생성MongoDBmongodb+srv://leetube:&amp;lt;password&amp;gt;@cluster0.xr2xb.mongodb.net/myFirstDatabase?retryWrites=true&amp;amp;w=majority먼저 MongoDB의 Connect 탭에서 Connect your application 항목을 선택한다. 제공되는 String 코드를 복사한 뒤, &..."
  },
  
  {
    "title": "Heroku 기본 사용법 (Heroku CLI)",
    "url": "/posts/2021-03-01-heroku-cli/",
    "categories": "service",
    "tags": "node, heroku",
    "date": "2021-03-01 00:00:00 +0800",
    





    "snippet": "Heroku CLI 설치brew tap heroku/brew &amp;amp;&amp;amp; brew install herokuHeroku CLI - Download and installheroku login정상적으로 설치되었거나, 이미 Heroku CLI가 설치되어 있는 경우 위와 같이 heroku login 명령어가 정상적으로 동작한다.새로운 Git 저장소 생성cd my-project/git init # 이미 있는 경우 생략heroku git:remote -a my-project참고로 Heroku는 무조건 git hist..."
  },
  
  {
    "title": "Express AWS S3를 사용한 파일 업로드 예제",
    "url": "/posts/2021-02-12-aws-s3-usage/",
    "categories": "node, express, service",
    "tags": "node, aws, s3, express",
    "date": "2021-02-12 00:00:00 +0800",
    





    "snippet": "Bucket 생성AWS S3 Bucket 생성.IAM User 생성AWS_ID = 123123;AWS_SECRET = 123123;IAM -&amp;gt; User -&amp;gt; 새로운 유저 생성. 액세스 키, 비밀 키 복사 후 .env 파일에 (사실 개발 환경에서는 로컬에 저장하면 되고, Heroku에서만 AWS로 저장하면 되기 때문에 .env 파일에 저장할 필요는 없지만 테스트를 위해서) 환경 변수로 정의하고, 똑같은 이름으로 Heroku Config Vars도 설정한다.Servernpm install --save mu..."
  },
  
  {
    "title": "내가 사용하는 Commit · PR 규칙",
    "url": "/posts/2021-02-04-commit-convention/",
    "categories": "development",
    "tags": "convention, git, github",
    "date": "2021-02-04 00:00:00 +0800",
    





    "snippet": "Commit 규칙$ git commit -m &quot;Prefix: Message (#issue)&quot;  Prefix: Message 형식으로 작성한다.  접두사는 모두 소문자로 작성한다.  접두사와 콜론 (:)은 띄어쓰지 않는다.  콜론과 메시지는 한 칸 띄어쓴다.  관련된 이슈 번호는 맨 뒤에 괄호 (())안에 작성한다.  메시지와 이슈 번호는 한 칸 띄어쓴다.메시지는 반드시 영어일 필요가 없으며, 가장 명확하고 짧게 쓸 수 있는 방법으로 작성한다. 예를들어 a.txt라는 파일을 삭제 했다면, 그것에 대해 설명하는 ..."
  },
  
  {
    "title": "내가 사용하는 Git 브랜치 전략 (Branch Strategy)",
    "url": "/posts/2021-02-03-branch-strategy/",
    "categories": "development",
    "tags": "convention, git",
    "date": "2021-02-03 00:00:00 +0800",
    





    "snippet": "전략브랜치 전략은 Git Flow, GitHub Flow 등이 있고, 선택적으로 사용하면 된다. 내 경우 혼자 일한지 오래되었기 때문에 나름의 규칙을 만들어놓고 지켜가며 일하는데, 이 브랜치 전략 역시 규칙 중 하나에 해당한다. (아마도 어쩌다보니 2개가 섞여서 내 입맛에 맞게 된듯)main배포 가능한 상태만을 병합하는 브랜치. 혼자 개발할 때는 대부분 이 main 브랜치에 대한 역할만 확실하다면 (GitHub Flow에서 지향하는 것처럼) 딱히 문제가 생길 일이 별로 없다. 그래서 블로그처럼 단순한 개발 (관리)의 경우 그냥..."
  },
  
  {
    "title": "내가 사용하는 GitHub Issue 관리를 위한 Label 규칙",
    "url": "/posts/2021-02-02-issue-label/",
    "categories": "development",
    "tags": "convention, github",
    "date": "2021-02-02 00:00:00 +0800",
    





    "snippet": "GitHub에서 이슈를 (또는 PR)을 작성할 때 기본적으로 제공되는 레이블은 다음과 같다.            Label      Description                  bug      Something isn’t working              documentation      Improvements or additions to documentation              duplicate      This issue or pull request already exists              enh..."
  },
  
  {
    "title": "오랜만에 리마인드 해보는 클린 코드를 위한 기본 규칙",
    "url": "/posts/2021-02-01-clean-code/",
    "categories": "development",
    "tags": "convention",
    "date": "2021-02-01 00:00:00 +0800",
    





    "snippet": "Clean Code  주석을 최소화 할 수 있는 코드  코드 작성자가 아닌 사람도 금방 배울 수 있는 코드  나중에 다시 읽을 때 ‘읽기 위한 공부’를 위해서 Additianal Cost를 지불하지 않아도 되는 코드  미래의 내가 똑같은 코드를 작성해도 (코드의 내용은 달라질 수 있지만) 일정한 포맷을 유지하는 코드Naming  단수와 복수를 구분  상수는 모두 대문자로 작성  a, b 따위의 초성 퀴즈 금지  항상 전 세계 공통 (영어) 누가봐도 유추할 수 있도록  변수명과 클래스명에는 동사가 아니라 명사를 사용  함수명에는..."
  },
  
  {
    "title": "[출판 소식] HTML5 독학백서",
    "url": "/posts/2021-01-27-book-publish-html5-for-beginners/",
    "categories": "notice",
    "tags": "notice, ebook, html",
    "date": "2021-01-27 00:00:00 +0800",
    





    "snippet": "제가 쓴 책 ≪HTML5 독학백서≫이 출판되어 소식 알립니다. 교보문고, 알라딘, 예스24, 밀리의서재, 구글플레이 등 다양한 유통사를 통해 구입하실 수 있으며, 현재는 eBook만 출간되어 판매 중 입니다. 많은 관심 부탁드립니다. 감사합니다.  HTML &amp;amp; CSS 무료 강의 바로가기  CSS Flex &amp;amp; Grid 강의 바로가기"
  },
  
  {
    "title": "2021 프론트엔드 · 백엔드 호스팅 서비스와 CDN 서비스 정리",
    "url": "/posts/2021-01-23-hosting-services/",
    "categories": "development",
    "tags": "bookmark, cdn, hosting",
    "date": "2021-01-23 00:00:00 +0800",
    





    "snippet": "Front-End            Service      Description                  GitHub Pages      공개 저장소 호스팅 무료비공개 저장소에서의 호스팅은 유료 월 $4              Glitch      공개 저장소 호스팅 무료비공개 저장소에서의 호스팅은 유료 월 $8              Google Cloud Storage      사용한 만큼 후불 결제              AWS S3      사용한 만큼 후불 결제              Vercel      개인..."
  },
  
  {
    "title": "iTerm2 세팅 방법",
    "url": "/posts/2021-01-20-setup-mac-terminal-with-iterm2/",
    "categories": "development",
    "tags": "mac, terminal, iterm, setting",
    "date": "2021-01-20 00:00:00 +0800",
    





    "snippet": "iTerm2 설치와 설정가장 먼저 다음의 명령어로 homebrew를 이용해 iTerm2를 설치한다. 최신 버전이 아닌 다른 버전을 설치하고 싶거나, homebrew를 사용하지 않는다면 공식 홈페이지를 참고하자.$ brew install --cask iterm2테마 설치와 적용다음으로는 컬러 테마를 변경하기 위해서 iTerm2 Color Schemes에서 마음에 드는 테마를 골라 .itermcolors 파일을 다운로드 한다. 설치는 다운로드 한 파일을 더블 클릭하면 된다.이제 iTerm2를 실행하고 iTerm2 - Prefere..."
  },
  
  {
    "title": "타입스크립트 Less · Default Parameter",
    "url": "/posts/2020-12-22-typescript-less-parameter/",
    "categories": "typescript",
    "tags": "typescript",
    "date": "2020-12-22 00:00:00 +0800",
    





    "snippet": "선택적 파라미터function greeting(name, age, gender) {  console.log(`Hello ${name}, you are ${age}, you are a ${gender}`);}greeting(name, age);// Hello stranger, you are 24, you are a undefined위 자바스크립트 예시에서, 함수 greeting은 3개의 인자를 사용하도록 선언되어있지만, 호출시 2개의 파라미터만 넘겨도 실행된다.index.ts:9:1 - error TS2554: Expected ..."
  },
  
  {
    "title": "타입스크립트 기초 토막 정리 #3 인터페이스",
    "url": "/posts/2020-12-21-typescript-interface/",
    "categories": "typescript",
    "tags": "typescript",
    "date": "2020-12-21 00:00:00 +0800",
    





    "snippet": "자바스크립트에서는 클래스를 인터페이스처럼 활용하기도 했지만, 타입스크립트는 그렇지 않다. 클래스와의 차이점은 이 글을 참고.interface Person {  name: string;  age: number;  gender: string;}// 인자가 Person과 같은지 확인function greeting(person: Person): void {  console.log(`${person.name}: ${person.age} years, ${person.gender}.`);}const obj = {  name: &quot;J..."
  },
  
  {
    "title": "타입스크립트 기초 토막 정리 #2 클래스",
    "url": "/posts/2020-12-20-typescript-class/",
    "categories": "typescript",
    "tags": "typescript",
    "date": "2020-12-20 00:00:00 +0800",
    





    "snippet": "자바스크립트의 클래스자바스크립트에서는 클래스가 가지고 있는 속성들에 대해 신경 쓸 필요가 별로 없다. 그냥 사용할 클래스 내용을 작성하기만 하면 된다. 자바스크립트에서 인터페이스가 필요할 때 (쓰고 싶을 때)는 클래스를 대신 사용할 수 있다.class Rectangle {  constructor(height, width) {    this.height = height;    this.width = width;  }  get area() {    return this.calcArea();  }  calcArea() {    re..."
  },
  
  {
    "title": "타입스크립트 기초 토막 정리 #1 타입 지정",
    "url": "/posts/2020-12-19-typescript-types/",
    "categories": "typescript",
    "tags": "typescript",
    "date": "2020-12-19 00:00:00 +0800",
    





    "snippet": "파라미터 타입 지정function greeting(name: string, age: number, gender: string) {  console.log(`${name}: ${age} years, ${gender}.`);}greeting(&quot;Jack&quot;, &quot;24&quot;, &quot;male&quot;);export {};타입스크립트에서는 파라미터의 타입을 위와 같이 지정할 수 있다. 위 코드를 컴파일하면 다음과 같은 에러가 발생한다.index.ts:5:18 - error TS2345: Argument..."
  },
  
  {
    "title": "타입스크립트를 사용하기 위한 기본 세팅 방법",
    "url": "/posts/2020-12-18-typescript-setting-up/",
    "categories": "typescript",
    "tags": "typescript, setting",
    "date": "2020-12-18 00:00:00 +0800",
    





    "snippet": "설치npm install -g typescript먼저 typescript를 Global로 설치한다. VS Code를 사용한다면, EsLint 확장을 설치한다. (TsLint 확장은 지원이 중단 되었기 때문에 더이상 사용되지 않는다.)설정{  &quot;compilerOptions&quot;: {    &quot;module&quot;: &quot;commonjs&quot;,    &quot;target&quot;: &quot;ES2015&quot;,    &quot;sourceMap&quot;: true  },  &quot;i..."
  },
  
  {
    "title": "Babel-CLI · Webpack을 사용해 Frontend · Backend 빌드하기",
    "url": "/posts/2020-12-18-webpack-steps-deploy/",
    "categories": "node, webpack",
    "tags": "babel, webpack, development",
    "date": "2020-12-18 00:00:00 +0800",
    





    "snippet": "Backendbabel-cli를 사용해 빌드하기npm install @babel/core @babel/cli -Dnodemon을 사용해서 babel-node를 실행. babel-node는 서비스는 되는 곳이 아니라 개발 환경에서 사용한다. babel-node는 퍼포먼스 문제가 (속도가 느림) 있는데, 따라서 매번 babel-node를 사용하는 게 아니라 아예 init.js (또는 server.js, app.js 등을) babel-cli를 사용해 CommonJS로 빌드해 주는 것이 좋다.&quot;scripts&quot;: { ..."
  },
  
  {
    "title": "Cookie · Session 기술의 이해",
    "url": "/posts/2020-12-11-sessions-cookies/",
    "categories": "web",
    "tags": "web, cookie, session",
    "date": "2020-12-11 00:00:00 +0800",
    





    "snippet": "Cookie와 Session을 사용하는 이유HTTP Protocol은 비연결성 (Connectionless)과 비상태성 (Stateless) 특징을 가지고 있다. 이 특징으로 인해 사용자가 요청할 때 마다 연결과 해제의 과정을 거치기 때문에 연결 상태를 유지하지 않고, 연결을 해지한 후에 상태 정보도 저장하지 않아 서버의 자원을 절약할 수 있다.하지만 이러한 특징으로 인해 사용자를 식별할 수 없어, 같은 사용자가 여러번 요청하더라도 매번 새로운 사용자로 인식한다는 단점이 존재하며, 이를 보완하기 위해 Cookie (이하 쿠키)..."
  },
  
  {
    "title": "Node GitHub 소셜 로그인 구현하기",
    "url": "/posts/2020-12-07-github-login/",
    "categories": "node",
    "tags": "node, express, github",
    "date": "2020-12-07 00:00:00 +0800",
    





    "snippet": "작업 흐름  Authorizing OAuth Apps  Users are redirected to request their GitHub identity  Users are redirected back to your site by GitHub  Your app accesses the API with the user’s access token애플리케이션 → GitHubGitHub New OAuth Application 페이지에서 새로운 애플리케이션을 등록하고 (홈페이지 URL은 localhost로 설정해두어도 됨) 발급되는 cli..."
  },
  
  {
    "title": "Node Bcrypt를 사용해 사용자 패스워드 해싱하기",
    "url": "/posts/2020-12-06-password-bcrypt/",
    "categories": "node",
    "tags": "node, express, bcrypt",
    "date": "2020-12-06 00:00:00 +0800",
    





    "snippet": "npm install bcrypt사용자 암호를 안전하게 저장하기 위해서 해싱한 (암호화 한) 다음 저장해야 함. 해싱 해주는 라이브러리가 bcrypt.암호화hashedPassword = await bcrypt.hash(this.password, 5);암호와 해시가 일치하는지 확인하기export async function postLogin(request, response) {  // 클라이언트 측에서 보낸 Body : 사용자가 입력한 계정 정보  const { username, password } = request.body;  ..."
  },
  
  {
    "title": "nodemon.json 파일 작성법 (프론트엔드 파일 예외 처리)",
    "url": "/posts/2020-12-05-nodemon-ignore/",
    "categories": "node",
    "tags": "node, express, nodemon",
    "date": "2020-12-05 00:00:00 +0800",
    





    "snippet": "// package.json&quot;scripts&quot;: {    // &quot;dev&quot;: &quot;nodemon --exec babel-node src/init.js&quot;    // 그냥 노드몬을 실행하도록 변경 -&amp;gt; nodemon.json 파일에 작성한 대로 실행됨    &quot;dev&quot;: &quot;nodemon&quot;,    &quot;assets&quot;: &quot;webpack --config webpack.config.js&quot;}{  // 프론트엔드 파일..."
  },
  
  {
    "title": "Node Multer를 사용해서 백엔드로 파일 전송하기",
    "url": "/posts/2020-12-04-node-multer/",
    "categories": "node",
    "tags": "node, express, multer",
    "date": "2020-12-04 00:00:00 +0800",
    





    "snippet": "클라이언트측에서 전송하는 데이터사용자 (클라이언트)가 앱 (서버)에 전송하는 정보는 크게 텍스트와 파일로 구분할 수 있다. 텍스트는 request.body를 통해 전달되며, express.urlencoded({ extended: true }를 사용해 파싱한다.npm install multer하지만 Express는 사용자가 업로드한 파일을 받아서 저장하는 기능을 기본으로 제공하지 않기 때문에, 파일을 전달받을 때는 multer 라이브러리를 활용한다.사용법 예시import multer from &quot;multer&quot;;e..."
  },
  
  {
    "title": "Node Morgan (HTTP Request Logger Middleware)",
    "url": "/posts/2020-12-03-node-morgan/",
    "categories": "node",
    "tags": "node, morgan",
    "date": "2020-12-03 00:00:00 +0800",
    





    "snippet": "Node용 HTTP 요청에 대한 로거 미들웨어.npm install morganimport morgan from &quot;morgan&quot;;app.use(morgan(&quot;dev&quot;));"
  },
  
  {
    "title": "Node Babel + Nodemon 적용 방법",
    "url": "/posts/2020-12-02-babel-nodemon/",
    "categories": "node",
    "tags": "node, babel, nodemon",
    "date": "2020-12-02 00:00:00 +0800",
    





    "snippet": "BabelNext-Gen 자바스크립트를 보편적인 (브라우저에서 안정적으로 실행할 수 있는) 자바스크립트로 변환하는 역할.{  &quot;presets&quot;: [&quot;@babel/preset-env&quot;]}babel.config.json 파일을 생성한다.npm install @babel/core @babel/register @babel/preset-env @babel/node필요한 의존성을 설치한다.babel-node index.jsNodemon변경 사항 (저장된)이 있을 경우 자동으로 서버를 재시작한다.npm ..."
  },
  
  {
    "title": "[출판 소식] 디지털 노마드를 꿈꾸는 당신이 알아야 하는 모든 것",
    "url": "/posts/2020-12-01-book-publish-digital-nomad/",
    "categories": "notice",
    "tags": "notice, ebook",
    "date": "2020-12-01 00:00:00 +0800",
    





    "snippet": "제가 쓴 책 ≪디지털 노마드를 꿈꾸는 당신이 알아야 하는 모든 것≫이 출판되어 소식 알립니다. 교보문고, 알라딘, 예스24, 밀리의서재, 구글플레이 등 다양한 유통사를 통해 구입하실 수 있으며, 현재는 eBook만 출간되어 판매 중 입니다. 많은 관심 부탁드립니다. 감사합니다."
  },
  
  {
    "title": "Node 파일 시스템 (FS) 모듈을 사용해서 파일 핸들링하는 방법",
    "url": "/posts/2020-12-01-node-fs/",
    "categories": "node",
    "tags": "node",
    "date": "2020-12-01 00:00:00 +0800",
    





    "snippet": "  Node.js v16.6.1 documentation파일 읽기function read(request, response) {  const { file } = request;  fs.readFile(file.path, &quot;utf8&quot;, (error, data) =&amp;gt; {    return response.render(&quot;read&quot;, { data });  });}s;특정 폴더에 위치한 파일 리스트 가져오기function home(request, response) {  fs.readdir(..."
  },
  
  {
    "title": ".prettierrc, .eslintrc 작성법",
    "url": "/posts/2020-11-14-eslint-prettier/",
    "categories": "eslint, development",
    "tags": "prettier, eslint",
    "date": "2020-11-14 00:00:00 +0800",
    





    "snippet": "Prettier{  &quot;arrowParens&quot;: &quot;always&quot;,  &quot;bracketSpacing&quot;: true,  &quot;endOfLine&quot;: &quot;auto&quot;,  &quot;printWidth&quot;: 80,  &quot;tabWidth&quot;: 4,  &quot;useTabs&quot;: false}.prettierrc 파일을 생성하고 위 코드 예제와 같이 원하는 설정을 작성한다. 설정을 적용하려면 파일을 저장하고 프로젝트 폴더를 재실행한다...."
  },
  
  {
    "title": "Express 세션 정보 유지를 위한 Connect-Mongo 사용법",
    "url": "/posts/2020-11-01-express-connect-mongo/",
    "categories": "node, express",
    "tags": "node, express, session, connect-mongo, express-session",
    "date": "2020-11-01 00:00:00 +0800",
    





    "snippet": "Express 환경에서 세션을 사용하기 위해서는 express-session 라이브러리를 사용한다. 이때 세션 데이터는 쿠키 자체에 저장되지 않고, 세션 아이디만 저장되며, 세션 데이터는 서버 측에 저장된다. 즉, 서버를 재시작하면 (nodemon 사용시 파일을 저장할 때마다) 세션 데이터는 초기화되는 문제가 발생하는 데, 이때 서버 재시작과 상관없이 세션을 유지하기 위해 connect-mongo를 사용한다.  Session data is not saved in the cookie itself, just the session ..."
  },
  
  {
    "title": "Express 미들웨어에서 App의 지역 변수 (response.locals) 공유하기",
    "url": "/posts/2020-10-03-express-request-response-locals/",
    "categories": "node, express",
    "tags": "node, express",
    "date": "2020-10-03 00:00:00 +0800",
    





    "snippet": "App (또는 서버)에서 사용하는 값을 HTML / Pug (View)에서 사용하고 싶거나, 서버에서 클라이언트 세션에 저장한 데이터를 HTML / Pug (View) 에서 접근하기 위해서는 해당 정보를 미들웨어에서 Hooking 해서 공유할 수 있게끔 해줘야 한다.app.use(localMiddlewares);export function localMiddlewares(request, response, next) {  response.locals.loggedIn = Boolean(request.session.loggedIn);..."
  },
  
  {
    "title": "Express 특정 경로 접근을 제한하는 미들웨어 만들기",
    "url": "/posts/2020-10-02-express-protector-middleware/",
    "categories": "node, express",
    "tags": "node, express",
    "date": "2020-10-02 00:00:00 +0800",
    





    "snippet": "특정 경로에 대해, 로그인한 유저와 로그인하지 않은 유저에 대해 다른 처리 (페이지 제공, 경로 제공 등)를 하고 싶을 때는 미들웨어를 사용해 로그인한 유저만 접근 가능하거나, 로그인하지 않은 유저만 접근 가능하도록 접근을 제한할 수 있다.export function loggedInOnly(request, response, next) {  if (request.session.loggedIn) {    next();  } else {    return response.redirect(&quot;/login&quot;);  }}위..."
  },
  
  {
    "title": "Express 미들웨어 (Middleware) 사용법",
    "url": "/posts/2020-10-01-express-middleware/",
    "categories": "node, express",
    "tags": "node, express",
    "date": "2020-10-01 00:00:00 +0800",
    





    "snippet": "전체 경로에 적용되는 미들웨어// middlewaresapp.use(logger);app.use(express.urlencoded({ extended: true }));app.use(localMiddlewares);// routersapp.use(&quot;/&quot;, globalRouter);app.use(&quot;/users&quot;, userRouter);전체 경로에 (애플리케이션 전체에) 적용되는 미들웨어는 애플리케이션의 라우터 상단에 use() 메소드를 사용해 지정한다.특정 경로에 적용되는 미들웨어app.get..."
  },
  
  {
    "title": "클라이언트에서 Express 서버로 텍스트 · JSON 데이터 전송하기",
    "url": "/posts/2020-09-22-express-request-body-text-json/",
    "categories": "node, express",
    "tags": "node, express",
    "date": "2020-09-22 00:00:00 +0800",
    





    "snippet": "Request.body 만들어 서버로 보내기fetch(`/api/posts/${id}/comment`, {  method: &quot;POST&quot;,  body: { text },});서버 측으로 POST 요청을 보낼 때, 반드시 form을 통해서 Sumbit 하지 않아도, 위와 같이 fetch를 사용해 POST 요청을 보낼 수 있으며, body 프로퍼티에 정보를 담아 보낼 수 있다. 하지만 이때 위와 같이 담긴 text는 서버측에서 console.log(request.body)를 하려고 해도 출력되지 않는데, 그 이유는..."
  },
  
  {
    "title": "Express 클라이언트에 상태 코드와 함께 객체 전달하기",
    "url": "/posts/2020-09-21-express-response-status-json/",
    "categories": "node, express",
    "tags": "node, express",
    "date": "2020-09-21 00:00:00 +0800",
    





    "snippet": "Backendapp.use(express.json());return response.status(201).json({ title: something, name: somethings });json() 메소드를 사용해서 객체를 전달한다.Frontendif (response.status === 201) {  const { title, name } = await response.json();  // ... 생략 ...}"
  },
  
  {
    "title": "Express 문자열 패턴과 정규식 표현을 사용한 Route 경로 표현",
    "url": "/posts/2020-09-20-express-route-url-string-pattern/",
    "categories": "node, express, regexp",
    "tags": "node, express, regexp",
    "date": "2020-09-20 00:00:00 +0800",
    





    "snippet": "라우트 경로를 문자열을 기반으로 하는 경우, 문자열 패턴 또는 정규식 문자를 사용해 조합할 수 있다. (- (하이픈)과 . (점)은 그냥 문자 그대로 해석됨)app.get(&quot;/&quot;, home);app.get(&quot;/about&quot;, about);위 라우트 경로는 정확히 입력된 대로 /, /about를 의미한다.? (물음표)app.get(&quot;/ab?cd&quot;, test);? 물음표를 사용하면 앞쪽에 위치한 b가 있을 수도 있고, 없을 수도 있다는 것을 의미한다. 즉, /abcd 일수도 있고..."
  },
  
  {
    "title": "Express 클라이언트에 상태 코드 (Status Code) 전송하기",
    "url": "/posts/2020-09-19-express-send-status-codes/",
    "categories": "node, express",
    "tags": "node, express",
    "date": "2020-09-19 00:00:00 +0800",
    





    "snippet": "if (password !== confirmPassword) {  return response.status(400).render(&quot;createAccount&quot;, {    pageTitle,    errorMessage: &quot;Password confirmation does not match.&quot;,  });}서버에서 클라이언트 측에 response를 보낼 때, 상태 코드를 포함하기 위해서는 위 코드 예제와 같이 response.status() 메소드를 사용한다.res.sendStatus(200); /..."
  },
  
  {
    "title": "Express 라우팅 (Routing) 방법 총정리",
    "url": "/posts/2020-09-18-express-routing/",
    "categories": "node, express",
    "tags": "node, express",
    "date": "2020-09-18 00:00:00 +0800",
    





    "snippet": "app.get(&quot;/&quot;, (request, response) =&amp;gt; response.send(&quot;Hello I&#39;m Home!&quot;));GET 요청에 대한 라우트를 생성할 때는 get() 메소드를, POST 요청에 대한 라우트를 생성할 때는 post() 메소드를 사용하며, 첫 번째 인자는 라우트 경로를, 두 번째 인자는 미들웨어 (생략 가능) 또는 해당 경로를 담당하는 컨트롤러 함수를 가진다.같은 경로에 대한 단축 표현// app.get(&quot;/join&quot;, (reque..."
  },
  
  {
    "title": "Express URL에 변수 사용하기",
    "url": "/posts/2020-09-17-express-url-params/",
    "categories": "node, express",
    "tags": "node, express",
    "date": "2020-09-17 00:00:00 +0800",
    





    "snippet": "http://abc.com/user/1http://abc.com/user/2위와 같이 변수를 사용해야 할 때./user/:id해당 부분을 콜론 + 변수명으로 표현한다.app.get(&quot;/user/:id&quot;, (request, response) =&amp;gt; {  console.log(request.params.id);});해당 파라미터를 파싱할 때는 request.params.id로 접근한다.사용 예시app.get(&quot;/posts/:id&quot;, postDetail);function postDeta..."
  },
  
  {
    "title": "Express 세션을 사용한 로그인 기능 구현",
    "url": "/posts/2020-09-16-express-session-login-logout/",
    "categories": "node, express",
    "tags": "node, express, express-session, session",
    "date": "2020-09-16 00:00:00 +0800",
    





    "snippet": "로그인 처리 예시  로그인 = 사용자를 인가하는 것을 의미한다.  인가됨을 어떻게 유지할 것인가? = 세션을 사용한다.export async function postLogin(request, response) {  // ... 생략 ...  // 데이터베이스에 해당 사용자가 있고, 패스워드가 일치할 경우 로그인 처리  // 세션에 인가 (request.session.loggedIn = true) 여부 저장 및 사용자 정보 저장  request.session.loggedIn = true;  request.session.user ..."
  },
  
  {
    "title": "Express 클라이언트의 세션 정보를 업데이트하는 방법",
    "url": "/posts/2020-09-15-express-update-session/",
    "categories": "node, express",
    "tags": "node, express, express-session, session",
    "date": "2020-09-15 00:00:00 +0800",
    





    "snippet": "세션의 정보를 업데이트하는 것이 필요한 이유를 이해하기 위해서, 다음과 같은 상황을 가정해보자.  로그인 정보가 세션에 저장되어있다. 세션에 정보를 저장하는 시점은 사용자가 로그인에 성공한 시점이다.  이때 사용자는 정보 변경 페이지에서 로그인 정보를 수정하고자 한다. 이때 데이터베이스에 저장된 사용자의 정보는 세션에 저장된 로그인 정보 (_id)를 토대로 변경할 수 있다.  데이터베이스에서는 수정되었지만, 세션에 저장된 정보는 사용자가 로그인한 시점에 저장된 정보가 그대로 유지되고 있기 때문에, 세션 정보를 사용하는 HTML..."
  },
  
  {
    "title": "Express 세션에 정보를 추가하고 사용하는 방법",
    "url": "/posts/2020-09-14-express-request-session/",
    "categories": "node, express",
    "tags": "node, express, express-session, session",
    "date": "2020-09-14 00:00:00 +0800",
    





    "snippet": "선행 조건Express 세션 관리를 위한 Express-Session 사용법세션에 정보 추가하는 방법// add information to sessionrequest.session.loggedIn = true;request.session.user = user;}request.session.key = value 형식으로 세션에 정보를 추가한다.세션 정보를 클라이언트와 공유하기세션 정보를 클라이언트와 공유하기 위해서는 세션의 정보를 미들웨어에서 Hooking 해서 locals에 저장하면 된다.export function local..."
  },
  
  {
    "title": "Express 세션 관리를 위한 Express-Session 사용법",
    "url": "/posts/2020-09-13-express-session/",
    "categories": "node, express",
    "tags": "node, express, express-session, session",
    "date": "2020-09-13 00:00:00 +0800",
    





    "snippet": "npm install express-sessionExpress에서 세션을 관리하기 위한 미들웨어.import session from &quot;express-session&quot;;// 반드시 라우터 위쪽에 위치하게끔 작성// session({ secret, resave, saveUninitialized })app.use(  session({    secret: &quot;Hello!&quot;,    resave: true,    saveUninitialized: true,  }));app.use((request, resp..."
  },
  
  {
    "title": "Express-Flash를 사용해 플래시 메시지 띄우기",
    "url": "/posts/2020-09-12-express-flash/",
    "categories": "node, express",
    "tags": "node, express, express-flash",
    "date": "2020-09-12 00:00:00 +0800",
    





    "snippet": "npm install express-flash휘발성 메시지 (플래시 메시지)를 관리할 수 있는 미들웨어.  Flash is an extension of connect-flash with the ability to define a flash message and render it without redirecting the request.사용법 예시import flash from &quot;express-flash&quot;;app.use(flash());request.flash(&quot;error&quot;, &quot;Not..."
  },
  
  {
    "title": "Express Request 객체의 이해 및 사용법",
    "url": "/posts/2020-09-11-express-params-body-query/",
    "categories": "node, express",
    "tags": "node, express",
    "date": "2020-09-11 00:00:00 +0800",
    





    "snippet": "request 객체는 HTTP Request로, parameters, body, query string, HTTP header 등의 Property를 가진다. (Node의 request 객체보다 향상된 버전)  request.params  request.body  request.queryrequest.paramsfunction postDetail(request, response) {  // const id = request.params.id;  const { id } = request.params;}request.params는..."
  },
  
  {
    "title": "Node DotEnv를 사용해서 환경 변수 사용하기",
    "url": "/posts/2020-09-11-express-dotenv/",
    "categories": "node",
    "tags": "node, dotenv, express",
    "date": "2020-09-11 00:00:00 +0800",
    





    "snippet": "npm install dotenvExpress 환경에서 API 주소, API KEY, DB URL 등의 환경 변수를 process.env.변수명으로 접근해 사용하기 위해서 dotenv 라이브러리를 사용한다. (참고 : Node.js - process.env)사용법 예시COOKIE_SECRET=adsfasdfasdfasdfMONGODB_URL=mongodb://127.0.0.1:27017/project가장 먼저 프로젝트 루트 위치에 .env 파일을 만들고 위와 같이 사용할 환경 변수를 세팅한다. (환경 변수는 String 형식으..."
  },
  
  {
    "title": "Express 클라이언트가 보낸 Body 정보 파싱하는 방법",
    "url": "/posts/2020-09-10-express-parsing-body/",
    "categories": "node, express",
    "tags": "node, express, body-parser",
    "date": "2020-09-10 00:00:00 +0800",
    





    "snippet": "클라이언트 측에서 POST 또는 PUT 메소드로 요청할 때 Body를 포함하여 보낼 수 있는데, 이 Body 정보를 서버 측에서 받아 사용할 수 있는 (해석할 수 있는) 형태로 변형해야 사용 할 수 있기 때문에 파싱하는 과정이 필요하다.Express 내장 함수 사용export function postEdit(request, response) {  const { id } = request.params;  // Parsing Body =&amp;gt; undefined  console.log(request.body);  retur..."
  },
  
  {
    "title": "Express 기본 사용법과 주요 메소드 정리",
    "url": "/posts/2020-09-09-express-basic-methods/",
    "categories": "node, express",
    "tags": "node, express",
    "date": "2020-09-09 00:00:00 +0800",
    





    "snippet": "Express란?Node.js를 위한 가벼운 Back-End (or Server-Side) Framework.  웹 어플리케이션을 만들기 쉬워진다.  가볍고 빠르며, 무료이다.  Request와 Response를 통제할 수 있다.기본 사용법  Express는 CommonJS를 사용하기 때문에 ES6+ 문법을 사용하기 위해서는 Babel 설정이 필요하다.import express from &quot;express&quot;;const app = express(); // express 어플리케이션 생성app.get(&quot;/&..."
  },
  
  {
    "title": "특정 단어로 시작하거나 끝나는 문자열을 검사하는 정규식 표현",
    "url": "/posts/2020-09-07-regexp-startswith-endwith/",
    "categories": "regexp",
    "tags": "regexp",
    "date": "2020-09-07 00:00:00 +0800",
    





    "snippet": "앵커 (Anchor)캐럿 기호인 다음 두 기호를 앵커 (Anchor)라고 한다. 이 두 개의 앵커를 사용해서 문자열이 특정 단어로 시작하거나, 끝나는지 여부를 검사하는 정규식 표현을 만들 수 있다.  ^ : 텍스트의 시작  $ : 텍스트의 끝특정 단어로 시작하는 문자열const string = &quot;Hello World!&quot;;/^Hello/는 문자열이 시작하고 바로 Hello가 나타난다는 뜻으로, 문자열이 Hello로 시작하는지 검사할 수 있다. 이를 대신해 자바스크립트의 문자열 메소드 startsWith()를 사..."
  },
  
  {
    "title": "Mongoose 페이징 (Paginate) 방법",
    "url": "/posts/2020-08-17-pagination/",
    "categories": "node, express, mongodb",
    "tags": "node, mongodb, express, mongoose",
    "date": "2020-08-17 00:00:00 +0800",
    





    "snippet": "전체 데이터 개수const posts = await Post.find({}).populate(&quot;owner&quot;);const totalCount = posts.length;라인 1과 같이 데이터베이스 검색 결과를 가져올 때, 결과를 담은 posts는 배열이 된다. (예외 처리 필요) 따라서 전체 게시글의 개수를 posts.length로 구할 수 있다.Query 처리프론트 쪽에서 GET 요청을 보내는 URL은 /posts 이며, /posts?page=1와 같이 페이지 번호를 쿼리에 담아 보낸다.const {  que..."
  },
  
  {
    "title": "SPA · MPA · PWA · CSR · SSR에 대한 이해",
    "url": "/posts/2020-08-17-ssr-csr-react-next/",
    "categories": "development, web",
    "tags": "development, web, csr, ssr, spa, mpa, pwa",
    "date": "2020-08-17 00:00:00 +0800",
    





    "snippet": "SPA vs. MPASPA는 Single Page Application, MPA는 Multiple Page Application의 약자로, 애플리케이션이 몇 개의 페이지로 구성되었는지로 구분하는 용어이다. 이 둘의 주요 특징은 다음과 같다.SPA 개요SPA는 한 개의 페이지로 구성된 애플리케이션을 의미하며, 애플리케이션을 구동하는데 필요한 모든 정적 리소스들을 페이지 최초 로드시 한 번에 다운로드하고, 새로운 페이지에 대한 요청이 생겼을 때 → 페이지를 갱신하는 데 필요한 데이터만 전달 받아 화면을 갱신한다. 이와 같은 특징에..."
  },
  
  {
    "title": "Mongoose 기본 제공 미들웨어 사용법",
    "url": "/posts/2020-08-16-mongoose-usage-middleware/",
    "categories": "node, express, mongodb",
    "tags": "node, mongodb, express, mongoose",
    "date": "2020-08-16 00:00:00 +0800",
    





    "snippet": "Mongoose는 4가지 종류의 미들웨어를 제공한다. (참고 : Mongoose Middleware)  document middleware  model middleware  aggregate middleware  query middleware미들웨어는 스키마를 구현하고 모델을 내보내는 파일에서 정의하고, 사용되기 전에 Hooking 된다.import mongoose from &quot;mongoose&quot;;const postSchema = new mongoose.Schema({  title: { type: String, ..."
  },
  
  {
    "title": "Mongoose Static 메소드 생성 및 사용법",
    "url": "/posts/2020-08-15-mongoose-static/",
    "categories": "node, express, mongodb",
    "tags": "node, mongodb, express, mongoose",
    "date": "2020-08-15 00:00:00 +0800",
    





    "snippet": "Static이란 Model.create(), Model.save()와 같이 접근하여 사용할 수 있는 사용자 정의 함수를 말한다. (참고 : Methods and Statics) 모델의 객체 인스턴스가 살아있을 때만 호출 할 수 있는 Method와는 달리, 객체를 생성하지 않아도 바로 컬렉션에 있는 데이터에 접근할 수 있기 때문에 데이터 조회와 관련된 API를 만들 때 사용된다.userSchema.statics.findUser = async function (id: string) {  return this.findOne({ id..."
  },
  
  {
    "title": "Oh-My-Zsh 사용자 이름 삭제 + 현재 디렉토리만 표시하기",
    "url": "/posts/2020-08-15-oh-my-zsh-settup/",
    "categories": "development",
    "tags": "mac, terminal, iterm, setting",
    "date": "2020-08-15 00:00:00 +0800",
    





    "snippet": "현재 디렉토리만 표시하기~/.oh-my-zsh/themes 디렉토리에서 사용하는 테마 파일을 연다.cd ~/.oh-my-zsh/themesvim agnoster.zsh-theme다음과 같은 부분을 찾는다.# Dir: current working directoryprompt_dir() {  prompt_segment blue $CURRENT_FG &#39;%~&#39;}아래와 같이 &#39;%~&#39; 부분을 수정한다.# Dir: current working directoryprompt_dir() {  prompt_segmen..."
  },
  
  {
    "title": "타입스크립트 객체 배열의 타입 (React but target allows only 1 에러 해결 방법)",
    "url": "/posts/2020-08-14-react-typescript-define-tuple/",
    "categories": "typescript, react",
    "tags": "typescript, react, error",
    "date": "2020-08-14 00:00:00 +0800",
    





    "snippet": "멘티들이 가장 많이하는 질문 중에 하나.오늘도 같은 질문을 받아서 정리해본다. 🐥Source has X element(s) but target allows only 1.앞쪽 메시지는 다를 수 있지만 위와 거의 흡사한 에러 메시지가 확인되는 경우. 이 에러는 하나의 엘리먼트에 해당하는 타입만을 지정해놓고, 다수의 엘리먼트를 넣으려고 했기 때문에 발생한다. 예를 들어서 다음과 같이 하나의 엘리먼트가 객체로 표현되는 배열을 가정해보자.const list = [  { id, text: &quot;hello&quot; },  { id,..."
  },
  
  {
    "title": "Mongoose 콜백 함수의 이해",
    "url": "/posts/2020-08-14-mongoose-understand-async/",
    "categories": "node, express, mongodb",
    "tags": "node, mongodb, express, mongoose",
    "date": "2020-08-14 00:00:00 +0800",
    





    "snippet": "import Post from &quot;../models/Post&quot;;export function home(request, response) {  Post.find({}, (error, posts) =&amp;gt; {    console.log(&quot;error: &quot;, error);    console.log(&quot;posts: &quot;, posts);  });  return response.render(&quot;home&quot;, { posts });}위 코드는 Post 스키마를 등록한 다음..."
  },
  
  {
    "title": "Node 랜덤한 아이디 값 생성을 위한 UUID 라이브러리 사용법",
    "url": "/posts/2020-08-14-random-id-uuid/",
    "categories": "node",
    "tags": "node, uuid",
    "date": "2020-08-14 00:00:00 +0800",
    





    "snippet": "uuid는 네트워크 상에서 고유성이 보장되는 아이디 값을 만들기 위한 표준 규약 UUID를 CommonJS, Node, 브라우저 환경 등에서 사용할 수 있는 라이브러리이다.npm install uuid타입스크립트로 사용하려면 @types/uuid도 설치해준다.npm install @types/uuid다음과 같이 v4 모듈을 import 한다.import { v4 as uuidv4 } from &quot;uuid&quot;;다음과 같이 랜덤 아이디를 생성할 수 있다.const id = uuidv4();"
  },
  
  {
    "title": "테스트 주도 개발 (TDD)이란?",
    "url": "/posts/2020-08-13-what-is-tdd/",
    "categories": "tdd",
    "tags": "tdd, javascript, jest, mocha, sholud, supertest",
    "date": "2020-08-13 00:00:00 +0800",
    





    "snippet": "테스트 주도 개발 (Test Driven Development, TDD)이란, 개발시 작은 단위로 테스트 코드를 먼저 작성하고, 해당 테스트를 통과하는 코드를 추가하는 과정을 반복해서 프로그램을 개발하는 소프트웨어 방법론을 말한다.학습의 단계를 넘어, 실무 프로젝트에서 TDD를 적용하는 경우, 아무래도 테스트 코드를 작성하고 → 테스트하고 → 통과하면 코드를 추가하는 등 일련의 과정 때문에 더 많은 시간이 소요되는 것은 사실이다. 하지만 프로젝트의 규모가 크고 복잡할 수록 안정성, 유지보수 등 종합적 (최종적)으로 놓고 봤을 ..."
  },
  
  {
    "title": "React useReducer 사용시 발생하는 TS2769 에러 해결 방법",
    "url": "/posts/2020-08-13-react-typescript-usereducer-ts2769-error/",
    "categories": "react",
    "tags": "react, typescript, error, hook",
    "date": "2020-08-13 00:00:00 +0800",
    





    "snippet": "에러 메시지No overload matches this call.Overload 1 of 5, &#39;(reducer: ReducerWithoutAction&amp;lt;any&amp;gt;, initializerArg: any, initializer?: undefined): [any, DispatchWithoutAction]&#39;, gave the following error.Argument of type &#39;(state: State, action: Action) =&amp;gt; void&#39; is not a..."
  },
  
  {
    "title": "Mongoose 기존의 데이터를 가져와서 업데이트하기",
    "url": "/posts/2020-08-13-mongoose-update-data/",
    "categories": "node, express, mongodb",
    "tags": "node, mongodb, express, mongoose",
    "date": "2020-08-13 00:00:00 +0800",
    





    "snippet": "export async function postEdit(request, response) {  const { id } = request.params;  const post = await Post.exists({ _id: id });  const { title, description } = request.body;  if (!post) {    return response.render(&quot;404&quot;, { pageTitle: &quot;Post not found.&quot; });  }  post.title = ti..."
  },
  
  {
    "title": "Mongoose 클라이언트가 전달한 정보를 데이터베이스에 저장하기",
    "url": "/posts/2020-08-12-create-model-save/",
    "categories": "node, express, mongodb",
    "tags": "node, mongodb, express, mongoose",
    "date": "2020-08-12 00:00:00 +0800",
    





    "snippet": "요약  클라이언트가 서버측으로 어떤 정보를 전달 (POST)  서버는 해당 정보를 Mongoose 모델로 작성  작성된 모델을 데이터베이스에 추가클라이언트block content    form(method=&quot;POST&quot;)        input(name=&quot;title&quot;, placeholder=&quot;Title&quot;, type=&quot;text&quot;, required)        input(name=&quot;description&quot;, placeholder=&quot;De..."
  },
  
  {
    "title": "React Context API와 Hooks 기초 이해",
    "url": "/posts/2020-08-11-react-context-api-hooks/",
    "categories": "react",
    "tags": "react, context, hook",
    "date": "2020-08-11 00:00:00 +0800",
    





    "snippet": "Context란?기본적으로 리액트에서는 props를 사용해서 부모 컴포넌트에서 자식 컴포넌트로 데이터를 공유할 수 있다. 이때 컴포넌트의 개수가 많고 구성이 복잡할 수록, 아래와 같이 여러 개의 컴포넌트에서 자식 컴포넌트로 props를 복잡하게 전달해야 하고, 실질적으로 그것을 사용하기 위해서보다 전달만을 위해 다루는 일이 많아지게 된다.메인 페이지 컴포넌트 # 헤더에게 props 전달    - 헤더 # 타이틀에게 props 전달        - 타이틀 # 로고에게 props 전달            - 로고 # 전달받은 pr..."
  },
  
  {
    "title": "Mongoose 스키마 (Schema) 생성하기",
    "url": "/posts/2020-08-11-mongoose-schema/",
    "categories": "node, mongodb",
    "tags": "node, mongodb, express, mongoose",
    "date": "2020-08-11 00:00:00 +0800",
    





    "snippet": "MongoDB, Redis와 같은 NoSQL 데이터베이스는 테이블이 존재하지 않기 때문에 편리함과 동시에 의도하지 않은 데이터나 데이터 타입이 삽입되는 경우가 생길 수 있다. 이러한 문제를 사전에 방지하기 위해 Mongoose는 사전에 스키마를 작성해놓고, 데이터를 데이터베이스에 추가하기 전에 스키마를 토대로 검사를 한 뒤, 스키마의 정의와 다른 데이터가 있을 경우 에러를 발생시킨다. (참고) 스키마를 정의할 때는 데이터 타입뿐 아니라 인덱스를 설정하거나, 기본 값을 설정할 수도 있다.)import mongoose from &..."
  },
  
  {
    "title": "React FontAwesome 라이브러리 사용법",
    "url": "/posts/2020-08-10-fontawesome-react/",
    "categories": "react",
    "tags": "react, fontawesome",
    "date": "2020-08-10 00:00:00 +0800",
    





    "snippet": "설치FontAwesome 공식 홈페이지에서 제공하는 리액트 문서를 참고해서 필수 라이브러리를 설치한다.npm install --save @fortawesome/fontawesome-svg-corenpm install --save @fortawesome/react-fontawesomenpm install --save @fortawesome/free-solid-svg-iconsfree-solid-svg-icon 외에도 사용할 아이콘 세트가 있다면 다음과 같이 추가 스타일을 설치할 수 있다. 즉, Solid 스타일을 사용한다면 fr..."
  },
  
  {
    "title": "Mongoose 참조를 위한 populate() 사용법",
    "url": "/posts/2020-08-10-mongodb-mongoose-populate/",
    "categories": "node, mongodb",
    "tags": "node, mongodb, express, mongoose",
    "date": "2020-08-10 00:00:00 +0800",
    





    "snippet": "export async function postDetail(request, response) {  const { id } = request.params;  const post = await Post.findById(id).populate(&quot;owner&quot;);  if (!post) {    return response.status(404).render(&quot;404&quot;);  }  return response.render(&quot;postDetail&quot;, {    post,  });}populat..."
  },
  
  {
    "title": "Mongoose 설치 및 세팅 방법",
    "url": "/posts/2020-08-09-express-setup-mongoose/",
    "categories": "node, mongodb",
    "tags": "node, mongodb, express, mongoose",
    "date": "2020-08-09 00:00:00 +0800",
    





    "snippet": "npm install mongooseimport mongoose from &quot;mongoose&quot;;// URL은 터미널에서 mongo 실행 후 확인// URL 뒤에 /데이터베이스이름 으로 설정mongoose.connect(&quot;mongodb://127.0.0.1:27017/database_name&quot;, {  useNewUrlParser: true,  useUnifiedTopology: true,});const connetDB = () =&amp;gt; console.log(&quot;Connected ..."
  },
  
  {
    "title": "MongoDB CLI 특정 데이터베이스 · 컬렉션 데이터 삭제하는 방법",
    "url": "/posts/2020-08-06-usage-mongo-terminal/",
    "categories": "database, mongodb",
    "tags": "database, nosql, mongodb",
    "date": "2020-08-06 00:00:00 +0800",
    





    "snippet": "$ mongo # CLI 실행$ show dbs # 데이터베이스 목록 확인$ use project # 사용할 데이터베이스 선택$ show collections # 데이터베이스 내부에 존재하는 컬렉션 확인$ db.users.find() # 컬렉션 내부 데이터들 확인$ db.users.remove({}) # project &amp;gt; users 내 데이터 초기화"
  },
  
  {
    "title": "MongoDB 모델 간의 관계 설정과 1:N 관계 표현",
    "url": "/posts/2020-08-05-mongodb-1-n-relations/",
    "categories": "database, mongodb",
    "tags": "database, nosql, mongodb, express",
    "date": "2020-08-05 00:00:00 +0800",
    





    "snippet": "관계 설정MongoDB는 NoSQL 데이터베이스로 모델끼리의 관계를 직접 설정할 수 없다. 따라서 어떠한 관계를 표현하기 위해서 서로 다른 도큐멘트들이 서로를 참조할 수 있게끔 설정한다.const postSchema = new mongoose.Schema({  /* ... 생략 ... */  owner: {    type: mongoose.Schema.Types.ObjectId,    required: true,    ref: &quot;User&quot;,  },});위 코드 예제는 게시글 모델에 게시글을 소유한 사람의 Ob..."
  },
  
  {
    "title": "MongoDB 정규식 표현을 사용하는 방법",
    "url": "/posts/2020-08-04-mongodb-usage-regexp/",
    "categories": "database, mongodb, regexp",
    "tags": "database, nosql, mongodb, regexp, express",
    "date": "2020-08-04 00:00:00 +0800",
    





    "snippet": "export async function search(request, response) {  const { keyword } = request.query;  let posts = [];  if (keyword) {    posts = await Post.find({      title: {        // $regex: `.*${keyword}.*`, $options: &quot;i&quot;        $regex: new RegExp(keyword, &quot;i&quot;),      },    });  }  retur..."
  },
  
  {
    "title": "MongoDB E11000 duplicate key 에러 해결 방법",
    "url": "/posts/2020-08-03-mongodb-error-e1100-duplicate-key-error/",
    "categories": "database, mongodb",
    "tags": "database, nosql, mongodb, error",
    "date": "2020-08-03 00:00:00 +0800",
    





    "snippet": "증상UnhandledPromiseRejectionWarning: MongoError: E11000 duplicate key error collection: project.users index: usernname_1 dup key: { usernname: null }Model.create() 또는 Model.save()로 새로운 데이터를 저장하려고 시도할 때 생기는 중복에 관한 에러. 기존에 존재하던 키 설정이 지워지지 않아 생기는 오류이다.해결db.dropDatabase()db.users.dropIndexes()db 자체를 깨..."
  },
  
  {
    "title": "MongoDB 논리 연산자 사용법",
    "url": "/posts/2020-08-02-mongodb-logical-operators/",
    "categories": "database, mongodb",
    "tags": "database, nosql, mongodb, express",
    "date": "2020-08-02 00:00:00 +0800",
    





    "snippet": "  Logical Operatorsexport async function postJoin(request, response) {  const pageTitle = &quot;Create Account&quot;;  const { name, username, email, password, confirmPassword, location } =    request.body;  // 비밀번호와 비밀번호 확인이 일치하지 않을 경우 에러 메시지를 전송  if (password !== confirmPassword) {    return re..."
  },
  
  {
    "title": "로컬에 MongoDB 설치하기 (MongoDB Community · MongoD)",
    "url": "/posts/2020-08-01-mongodb-install/",
    "categories": "database, mongodb",
    "tags": "database, nosql, mongodb",
    "date": "2020-08-01 00:00:00 +0800",
    





    "snippet": "$ brew tap mongodb/brew$ brew install mongodb-community@4.4로컬에 Homebrew 사용해서 설치. (참고 : MongoDB Installation)$ brew services start mongodb-community@4.4$ brew services stop mongodb-community@4.4macOS service로 실행.$ mongod$ mongo2개 명령어 정상적으로 실행되는지 확인."
  },
  
  {
    "title": "Express 컨트롤러에서 전달한 변수 Pug 파일에서 사용하기",
    "url": "/posts/2020-07-13-pug-variables/",
    "categories": "node, express, pug",
    "tags": "node, pug, express",
    "date": "2020-07-13 00:00:00 +0800",
    





    "snippet": "doctype htmlhtml(lang=&quot;ko&quot;)    head        title #{title} | Site    body        block content        include ./footer.pugfunction home(request, response) {  const title = &quot;Hello World!&quot;;  return response.render(&quot;home&quot;, { title });}위와 같이 각각의 페이지가 랜더링 될 때 전달받은 변수를 사용할 ..."
  },
  
  {
    "title": "Express Pug 기본 사용법 + Failed to lookup view 에러 해결 방법",
    "url": "/posts/2020-07-12-pug-html-return/",
    "categories": "node, express, pug",
    "tags": "node, pug, express, error",
    "date": "2020-07-12 00:00:00 +0800",
    





    "snippet": "Express에서 특정 경로에 HTML 리턴function home(request, response) {  return response.send(&quot;&amp;lt;h1&amp;gt;Home&amp;lt;/h1&amp;gt;&quot;);}컨트롤러 부분의 response에 실어서 보냄. 하지만 이렇게 보내는 방식으로는 장문의 HTML을 전부 작성하기 어렵고, 복잡함.Pug 사용Pug는 Node.js 템플릿 엔진으로, HTML 문서를 보다 간편하게 (중복을 최소화하고) 작성하게 돕는다.app.set(&quot;view en..."
  },
  
  {
    "title": "Pug Dataset을 사용해서 백엔드와 데이터 공유하기",
    "url": "/posts/2020-07-11-pug-api-view/",
    "categories": "node, pug, express",
    "tags": "node, pug, express",
    "date": "2020-07-11 00:00:00 +0800",
    





    "snippet": "백엔드와 Pug는 서로 데이터를 공유할 수 있다. 하지만 프론트엔드 쪽에서 사용하는 자바스크립트에서는 이러한 정보에 접근할 수가 없는데, 이때 가장 간편하게 정보를 공유하는 방법은 HTML의 data-set을 사용하는 방법이다. (이외 방법 : localStorage 등)처리를 담당할 라우터import express from &quot;express&quot;;import { addComment } from &quot;../controllers/postController&quot;;const apiRouter = express..."
  },
  
  {
    "title": "Pug 긴 URL 줄이기 (Redirection)",
    "url": "/posts/2020-07-10-pug-make-url-backend/",
    "categories": "node, pug, express",
    "tags": "node, pug, express",
    "date": "2020-07-10 00:00:00 +0800",
    





    "snippet": "긴 URL의 문제점a(href=&quot;https://github.com/login/oauth/authorize?client_id=aasdffsafasdfasfsafsafsadf&amp;amp;allow_signup=false&amp;amp;scope=read:user user:email&quot;) GitHub위 코드는 GitHub 로그인 기능 구현을 위해 필요한 URL 링크를 생성하는 프론트엔드 코드이다. 예와 같이 URL이 길고 복잡하며, 파라미터를 구분하거나 수정하는 것이 어렵다.새로운 경로 생성문제를 해결하기 위해서..."
  },
  
  {
    "title": "Pug 스크립트 사용하는 페이지에서만 로드하기",
    "url": "/posts/2020-07-09-pug-block-scripts/",
    "categories": "node, pug",
    "tags": "node, pug",
    "date": "2020-07-09 00:00:00 +0800",
    





    "snippet": "특정 페이지에서만 필요한 자바스크립트 파일은 매 페이지마다 로딩할 필요가 없다. 따라서 block을 이용해 선택적으로 스크립트 파일을 가져올 수 있게끔 하는 것이 좋다.  See the Pen   Pug 스크립트 사용하는 페이지에서만 로드하기 by Dohae Lee (@dohaelee)  on CodePen.공통 레이아웃을 표현하는 layout.pug에 block 생성한다. block은 선택적으로 구현할 수 있기 때문에 스크립트가 필요한 위치에서만 스크립트 호출 구문을 추가하면 된다. 그런 다음 특정 스크립트를 사용해야 할 뷰..."
  },
  
  {
    "title": "Pug 기초 #8 상속 (Inheritance)",
    "url": "/posts/2020-07-08-pug-inheritance/",
    "categories": "node, pug",
    "tags": "node, pug",
    "date": "2020-07-08 00:00:00 +0800",
    





    "snippet": "레이아웃 틀은 같지만, 내용은 변경되어야 할 때. (변경되는 것 없이 똑같은 부분이 중복될 때는 이 글을 참고.)  See the Pen   Pug 기초 #8 상속 (Inheritance) by Dohae Lee (@dohaelee)  on CodePen.만든 레이아웃은 extends 키워드를 사용해 적용하고, 각각의 block (내용이 변경될 부분)을 구현한다. block 파트 구현은 옵션으로, 비워둬도 에러가 생기진 않는다."
  },
  
  {
    "title": "Pug 기초 #7 배열 반복 출력 예제",
    "url": "/posts/2020-07-07-pug-iterations/",
    "categories": "node, pug",
    "tags": "node, pug",
    "date": "2020-07-07 00:00:00 +0800",
    





    "snippet": "  See the Pen    by Dohae Lee (@dohaelee)  on CodePen."
  },
  
  {
    "title": "Pug 기초 #6 재사용 가능한 함수",
    "url": "/posts/2020-07-06-pug-mixins/",
    "categories": "node, pug",
    "tags": "node, pug",
    "date": "2020-07-06 00:00:00 +0800",
    





    "snippet": "Mixin은 재사용을 위한 모듈인데, 함수처럼 인자를 받아 처리할 수 있다.  See the Pen    by Dohae Lee (@dohaelee)  on CodePen.사용할 때는 해당 파일을 include 한 다음 +widget()와 같이 사용한다. 위 예제는 배열로 표현된 여러 개의 위젯 객체를 가져와 반복문을 통해 각각의 위젯에 동일한 템플릿을 적용하고 있다."
  },
  
  {
    "title": "Pug 기초 #5 중복되는 HTML 부분 모듈화",
    "url": "/posts/2020-07-05-pug-partials/",
    "categories": "node, pug",
    "tags": "node, pug",
    "date": "2020-07-05 00:00:00 +0800",
    





    "snippet": "다음 코드의 두 개의 Pug 파일 예시는 각각 다른 페이지를 표현하지만, footer 부분은 동일하다.  See the Pen   Pug 기초 #5 중복되는 HTML 부분 모듈화 by Dohae Lee (@dohaelee)  on CodePen.중복되는 부분 모듈화먼저 중복되는 부분을 모듈화 할 footer.pug 파일을 생성한다.  See the Pen   Pug 기초 #5 중복되는 HTML 부분 모듈화 1 by Dohae Lee (@dohaelee)  on CodePen.footer.pug 파일에 중복되는 부분을 작성하고,..."
  },
  
  {
    "title": "Pug 기초 #4 조건문 (Conditionals)",
    "url": "/posts/2020-07-04-pug-conditionals/",
    "categories": "node, pug",
    "tags": "node, pug",
    "date": "2020-07-04 00:00:00 +0800",
    





    "snippet": "  See the Pen    by Dohae Lee (@dohaelee)  on CodePen."
  },
  
  {
    "title": "Pug 기초 #3 상대 경로 다루기",
    "url": "/posts/2020-07-03-pug-href/",
    "categories": "node, pug",
    "tags": "node, pug",
    "date": "2020-07-03 00:00:00 +0800",
    





    "snippet": "  See the Pen   Pug 기초 #3 상대 경로 다루기 by Dohae Lee (@dohaelee)  on CodePen.URL 앞에 / 슬래시를 붙이면 현재 위치와 상관없이 루트 위치에서 지정한 경로로 이동한다. 즉, root/videos 경로로 이동하게 된다. / 슬래시를 생략할 경우 현재 위치의 상대 경로로 이동한다. 즉, 현재 위치가 root/videos 일때 root/videos/edit 경로로 이동하게 된다."
  },
  
  {
    "title": "Pug 기초 #2 태그에 값을 대입하는 네 가지 방법",
    "url": "/posts/2020-07-02-pug-initializing-element/",
    "categories": "node, pug",
    "tags": "node, pug",
    "date": "2020-07-02 00:00:00 +0800",
    





    "snippet": "  See the Pen   Pug 기초 #2 태그에 값을 대입하는 네 가지 방법 by Dohae Lee (@dohaelee)  on CodePen.  텍스트 대입  값 (변수) 대입  텍스트와 값 혼용  자바스크립트 코드 사용"
  },
  
  {
    "title": "Pug 기초 #1 자바스크립트 코드 사용법",
    "url": "/posts/2020-07-01-pug-javascript-code/",
    "categories": "node, pug",
    "tags": "node, pug",
    "date": "2020-07-01 00:00:00 +0800",
    





    "snippet": "  See the Pen   Pug 기초 #1 자바스크립트 코드 사용 by Dohae Lee (@dohaelee)  on CodePen.#{} 샾 기호와 중괄호 안에 자바스크립 코드를 작성한다."
  },
  
  {
    "title": "타입스크립트 .eslintrc 파일 Parsing Error 해결 방법",
    "url": "/posts/2020-06-14-tslint-error/",
    "categories": "eslint, typescript",
    "tags": "typescript, error, eslint",
    "date": "2020-06-14 00:00:00 +0800",
    





    "snippet": "증상.eslintrc.js 파일에 타입스크립트 (과거 .tslint) 설정을 할 때 발생하는 Parsing Error 또는 .eslintrc.js 파일 에러.parsing error: &quot;parseroptions.project&quot; has been set for @typescript-eslint/parser. the file does not match your project config: .eslintrc.js. the file must be included in at least one of the projects..."
  },
  
  {
    "title": "React Hook이란?",
    "url": "/posts/2020-06-12-what-is-hook/",
    "categories": "react",
    "tags": "react, javascript, hook",
    "date": "2020-06-12 00:00:00 +0800",
    





    "snippet": "함수 컴포넌트에서 state를 가질 수 있게 해준다. 참고예시class App extends React.Component {  state = {    count: 0,  };  add = () =&amp;gt; {    this.setState({ count: this.count + 1 });  };  render() {    const { count } = this.state;    return (      &amp;lt;div class=&quot;App&quot;&amp;gt;        &amp;lt;h1&amp;gt..."
  },
  
  {
    "title": "React 타입 검사를 위한 Prop-Types 사용법",
    "url": "/posts/2020-06-11-react-prop-types/",
    "categories": "react",
    "tags": "react, javascript",
    "date": "2020-06-11 00:00:00 +0800",
    





    "snippet": "타입 검사가 아주 중요하게 다뤄질 만큼 프로젝트 덩치가 커지면, 그냥 타입스크립트를 쓰는 것도 좋은 대안이다. 하지만, 어쩔 수 없이 자바스크립트로 프로젝트를 진행 해야 할 경우 prop-types를 사용하면 된다.npm install prop-types전달받은 Props가 의도한 Props인지 체크해주는 역할을 한다.import PropTypes from &quot;prop-types&quot;;// Componenetfunction Greeting({ name, age }) {  return (    &amp;lt;h1&a..."
  },
  
  {
    "title": "React 배열을 사용한 동적 컴포넌트 생성",
    "url": "/posts/2020-06-10-react-dynamic-component-generation/",
    "categories": "react",
    "tags": "react, javascript",
    "date": "2020-06-10 00:00:00 +0800",
    





    "snippet": "const family = [  {    name: &quot;John&quot;,    age: 24,  },  {    name: &quot;Edward&quot;,    age: 18,  },  {    name: &quot;Tim&quot;,    age: 20,  },];function renderMembers(member) {  return &amp;lt;Greeting name={member.name} age={member.age} /&amp;gt;;}function App() {  return (    &amp;..."
  },
  
  {
    "title": "React 컴포넌트의 라이프 사이클",
    "url": "/posts/2020-06-09-react-component-life-cycle/",
    "categories": "react",
    "tags": "react, javascript",
    "date": "2020-06-09 00:00:00 +0800",
    





    "snippet": "MountingMounting은 컴포넌트가 탄생하는 단계이며, 다음과 같은 순서로 새로운 컴포넌트가 생성된다.  constructor() : 자바스크립트에서 클래스를 만들 때 생성되는 생성자 함수.  static getDerivedStateFromProps()  render()  componentDidMount()class App extends React.Component {  state = {    count: 0,  };  constructor(props) {    super(props);    console.log(&qu..."
  },
  
  {
    "title": "React Routes 사이에 Props를 공유하는 방법",
    "url": "/posts/2020-06-08-react-sharing-props-between-routes/",
    "categories": "react",
    "tags": "react, javascript",
    "date": "2020-06-08 00:00:00 +0800",
    





    "snippet": "import React from &quot;react&quot;;function About(props) {  console.log(props);  return &amp;lt;h3&amp;gt;About this page: I build it!&amp;lt;/h3&amp;gt;;}export default About;위 코드 예제는 /about 경로로 이동했을 때 보여지는 About 컴포넌트이다. 인자로 props를 받고 있고, console.log()로 확인하고 있다. 이때 라우팅을 한 쪽에서는 아무것도 보내지 않고 있지만, ..."
  },
  
  {
    "title": "React HashRouter와 BrowserRouter의 차이점",
    "url": "/posts/2020-06-07-hashrouter-browserrouter/",
    "categories": "react",
    "tags": "react, javascript",
    "date": "2020-06-07 00:00:00 +0800",
    





    "snippet": "라우터의 종류  BrowserRouter  HashRouter  MemoryRouter  NativeRoter  StaticRouterHashRouter# 예 : abc.com/#/home  URL 앞에 해쉬 (#)가 붙는다.  검색 엔진이 읽지 못한다.  해쉬 히스토리 지원하지 않는다.  새로고침해도 에러가 나지 않는다.  정적인 페이지에 적합하다. (미리 저장된 페이지가 그대로 보여지는 페이지)  gh-pages를 사용할 때 좀 더 편하다.BrowserRouter  레거시 브라우저 (IE9 이하)에서는 사용할 수 없다.  ..."
  },
  
  {
    "title": "React Routing 기본 이해",
    "url": "/posts/2020-06-06-react-router-dom/",
    "categories": "react",
    "tags": "react, javascript",
    "date": "2020-06-06 00:00:00 +0800",
    





    "snippet": "npm install react-router-domimport React from &quot;react&quot;;import { HashRouter, Route } from &quot;react-router-dom&quot;;import Navigation from &quot;./components/Navigation&quot;;import About from &quot;./routes/About&quot;;import Home from &quot;./routes/Home&quot;;function App() {  retur..."
  },
  
  {
    "title": "Emotion 특징 정리 및 Styled-Components와의 비교",
    "url": "/posts/2020-06-06-overview-emotion/",
    "categories": "css-in-js",
    "tags": "emotion, styled-components, css-in-js",
    "date": "2020-06-06 00:00:00 +0800",
    





    "snippet": "Overviews  Styled-Components, Emotion 둘다 CSS-in-JS  Styled-Components 기능을 모두 제공Styled-Components와의 비교  Styled-Components 용량  @emotion/core 용량  NPM Trends  Benchmark ResultsProps 사용Styled-Components// Create an Input component that&#39;ll render an &amp;lt;input&amp;gt; tag with some stylesconst I..."
  },
  
  {
    "title": "React Styled-Component 현재 경로 메뉴 스타일 강조하기",
    "url": "/posts/2020-06-05-styled-componenets-withRouter/",
    "categories": "react, css-in-js",
    "tags": "react, styled-components, css-in-js",
    "date": "2020-06-05 00:00:00 +0800",
    





    "snippet": "withRouter현재 경로는 라우터에서 사용하는 객체인 location 내부에 pathname으로 알 수 있다. 이 location 객체는 라우트가 아닌 컴포넌트에서 사용할 수 없는데, 이를 가능하게 만들기 위해서 withRouter라는 HoC를 사용한다.현재 경로 메뉴 강조하기import React from &quot;react&quot;;import { Link, withRouter } from &quot;react-router-dom&quot;;import styled from &quot;styled-components..."
  },
  
  {
    "title": "React Styled-Component 글로벌 공통 스타일 지정하기",
    "url": "/posts/2020-06-04-styled-components-createGlobalStyle/",
    "categories": "react, css-in-js",
    "tags": "react, styled-components, css-in-js",
    "date": "2020-06-04 00:00:00 +0800",
    





    "snippet": "npm install styled-resetreset 파일 적용을 위해서 styled-reset를 설치한다.import { createGlobalStyle } from &quot;styled-components&quot;;import reset from &quot;styled-reset&quot;;const globalStyle = createGlobalStyle`    ${reset};    /* 공통 스타일 지정 */`;export default globalStyle;Components 폴더에 GlobalStyle.js 등..."
  },
  
  {
    "title": "React Container - Presenter 패턴",
    "url": "/posts/2020-06-03-react-container-presenter-pattern/",
    "categories": "react",
    "tags": "react, javascript",
    "date": "2020-06-03 00:00:00 +0800",
    





    "snippet": "React (이하 리액트)에서 Container - Presenter 패턴이란 데이터 처리 부분과 데이터 출력 (표현) 부분을 분리하여 개발 및 관리하는 디자인 패턴을 의미한다. 리액트 코드가 길어질 수록 컴포넌트 내부가 복잡해지기 때문에 유지보수 하기가 굉장히 번거로워 지는데, 이 디자인 패턴을 사용하면 데이터의 처리 부분과 출력 (표현)을 담당하는 부분을 나누어 작성하고 관리하기 때문에 코드의 가독성을 높일 수 있다.  Container : 데이터를 담당. 데이터와 상태 값을 가지고, API를 불러와서 모든 로직을 처리. ..."
  },
  
  {
    "title": "React 클래스 컴포넌트 state 사용하는 방법",
    "url": "/posts/2020-06-02-react-class-component-state/",
    "categories": "react",
    "tags": "react, javascript",
    "date": "2020-06-02 00:00:00 +0800",
    





    "snippet": "클래스 컴포넌트에서는 함수 컴포넌트에는 없는 state를 사용할 수 있다. state는 Object이며, 변경될 (변경할) 값을 다룬다.class App extends React.Component {  state = {    count: 0,  };}state는 클래스 컴포넌트 안에 state = {}; 형식으로 생성할 수 있다.state 사용class App extends React.Component {  state = {    count: 0,  };  render() {    return (      &amp;lt;div..."
  },
  
  {
    "title": "React 클래스 컴포넌트와 함수 컴포넌트의 차이점",
    "url": "/posts/2020-06-01-react-class-component/",
    "categories": "react",
    "tags": "react, javascript",
    "date": "2020-06-01 00:00:00 +0800",
    





    "snippet": "함수 컴포넌트function App() {  return (    &amp;lt;div className=&quot;App&quot;&amp;gt;      {members.map((member) =&amp;gt; {        return &amp;lt;Greeting name={member.name} age={member.age} /&amp;gt;;      })}    &amp;lt;/div&amp;gt;  );}함수 컴포넌트는 자체로 함수이기 때문에 뭔가를 리턴한다. 클래스 컴포넌트와는 달리 state를 가지고 있지 ..."
  },
  
  {
    "title": "React 컴포넌트 (Component)란?",
    "url": "/posts/2020-05-29-react-component/",
    "categories": "react",
    "tags": "react, javascript",
    "date": "2020-05-29 00:00:00 +0800",
    





    "snippet": "HTML을 반환하는 함수.function App() {  return &amp;lt;div className=&quot;App&quot;&amp;gt;Hello&amp;lt;/div&amp;gt;;}export default App;예시import React from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;import App from &quot;./App&quot;;ReactDOM.render(  &amp;lt;React.StrictMode&amp;gt;  ..."
  },
  
  {
    "title": "자바스크립트 Map · WeakMap 자료구조",
    "url": "/posts/2020-05-19-javascript-map-weakmap/",
    "categories": "javascript",
    "tags": "javascript",
    "date": "2020-05-19 00:00:00 +0800",
    





    "snippet": "객체의 단점  Iterable 하지 않다.  키를 문자열로만 취급한다.  따라서 키 값의 유일성을 완벽히 보장할 수 없다.  프로퍼티 개수를 직접 파악할 수 없다.const obj = {  name: &quot;John&quot;,  age: 25,  gender: &quot;male&quot;,};// 다음과 같이 사용할 수 없음// obj.length// 프로퍼티 개수를 알아내기 위한 방법Object.keys(obj).length;Object.values(obj).length;Map  객체의 단점을 보완  key와 valu..."
  },
  
  {
    "title": "자바스크립트 Set · WeakSet 자료구조",
    "url": "/posts/2020-05-18-javascript-set-weakset/",
    "categories": "javascript",
    "tags": "javascript",
    "date": "2020-05-18 00:00:00 +0800",
    





    "snippet": "const a = new Set();Set은 배열과 비슷하지만 인덱스가 없고, new 연산자를 사용해 생성한다. (순서는 가지고 있으며, 중복을 허용하지 않는다.) 이때 인자로는 Iterable한 요소 (배열, 문자열 등)가 들어갈 수 있다.중복을 제거한 배열 만들기const arr = [1, 2, 3, 3, 3, 4, 5];// reduce를 사용한 중복 제거 예제const newArr = arr.reduce((acc, current) =&amp;gt; {    if (acc.includes(current)) return a..."
  },
  
  {
    "title": "자바스크립트 setInterval()과 setTimeout()를 사용한 게임 오버 예제",
    "url": "/posts/2020-05-17-javascript-setInterval-setTimeout/",
    "categories": "javascript",
    "tags": "javascript",
    "date": "2020-05-17 00:00:00 +0800",
    





    "snippet": "setInterval() 메소드를 사용해서 (일정한) 특정 시간 간격으로 함수 A를 실행하고, setTimeout() 메소드를 사용해서 특정 시간 이후 종료하고 함수 B를 실행하는 예제.function setPlayTime() {  timer.innerText = PLAY_TIME;  // 매초 남은 게임 시간을 업데이트 함  timerId = setInterval(updateTime, 1000);  // 플레이 타임이 종료되면 게임 오버 함수를 실행함  setTimeout(gameOver, PLAY_TIME * 1000);}..."
  },
  
  {
    "title": "자바스크립트 Promise의 비동기 처리 방식",
    "url": "/posts/2020-05-16-javascript-promise-fetch-then/",
    "categories": "javascript",
    "tags": "javascript",
    "date": "2020-05-16 00:00:00 +0800",
    





    "snippet": "예를 들어 다음과 같이 어떤 서버에 요청을 보내 유저 정보를 가져온 다음 필요한 유저 정보만을 사용하는 경우를 가정해보자.function getUser() {  const response = fetch.get(&quot;https://api.com/users&quot;);  const users = fetch.get(`https://api.com/users/${response[3]}`);}이때 위 방식은 동기 방식으로, response를 기다리지 않고 바로 다음 줄이 실행되기 때문에 response[3]에 제대로 된 결과 값이..."
  },
  
  {
    "title": "자바스크립트 제네레이터 (Generator)의 이해",
    "url": "/posts/2020-05-15-javascript-generator/",
    "categories": "javascript",
    "tags": "javascript",
    "date": "2020-05-15 00:00:00 +0800",
    





    "snippet": "  중간에 멈췄다가 이어서 실행할 수 있는 함수  function 뒤에 *를 붙여 표현  함수를 멈출 때는 yield 키워드를 사용function* gen() {  console.log(1);  yield 1; // value : 1, done : false;  console.log(2);  yield 2; // value : 2, done : false;  console.log(3);}const result = gen();// result.next();Generator는 함수 실행 결과에 대해 next() 메소드를 호출할 때..."
  },
  
  {
    "title": "자바스크립트 이터레이터 (Iterator)의 이해",
    "url": "/posts/2020-05-14-javascript-iterator/",
    "categories": "javascript",
    "tags": "javascript",
    "date": "2020-05-14 00:00:00 +0800",
    





    "snippet": "Iterator는 반복을 위해 설계된 특별한 인터페이스를 가진 객체로, 객체 내부에 next() 라는 메소드가 존재하고, 이 메소드를 사용해 반복적으로 value와 done 프로퍼티를 가진 객체를 반환한다.Iterable한 개체 특징  구조 해체 할당 가능  펼쳐 쓸 수 있음 (Spread Syntax)  Array.from() 사용 가능Iterator 사용법const arr = [1, 2, 3];const iter = arr[Symbol.iterator]();iter.next(); // value : 1, done : fal..."
  },
  
  {
    "title": "CSS 잠깐 보여지고 사라지는 Flash Message 애니메이션 예제",
    "url": "/posts/2020-05-14-flash-message/",
    "categories": "css",
    "tags": "css, animation",
    "date": "2020-05-14 00:00:00 +0800",
    





    "snippet": "사용자가 로그인하거나 로그아웃할 때 사이트 왼쪽 하단에서 잠깐 동안 보여지고 사라지는 플래시 메시지창.&amp;lt;div class=&quot;notification&quot;&amp;gt;hello&amp;lt;/div&amp;gt;.notification {  opacity: 0;  position: absolute;  bottom: 0px;  right: 50px;  border-radius: 50px;  background-color: white;  padding: 1em 2em;  text-align: center;..."
  },
  
  {
    "title": "자바스크립트 이터러블 (Iterable)의 이해",
    "url": "/posts/2020-05-13-javascript-iterable/",
    "categories": "javascript",
    "tags": "javascript",
    "date": "2020-05-13 00:00:00 +0800",
    





    "snippet": "내부 요소들을 공개적으로 탐색 (반복)할 수 있는 데이터 구조를 Iterable 하다고 말하며, Iterable한 데이터 구조는 모두 프로토타입에 Symbol.iterator() 메소드를 가지고 있다.Iterable한 데이터 구조  Array  Map  Set  String예시const obj = {  0: 1,  1: 2,  2: 3,  length: 3,};// Symbol.iterator() 없음console.dir(obj);위에서 obj는 유사 배열 객체로, 배열과 유사하게 동작하지만 Symbol.iterator() 메..."
  },
  
  {
    "title": "CSS 천천히 사라지는 Fade Out 애니메이션 예제",
    "url": "/posts/2020-05-13-fade-out/",
    "categories": "css",
    "tags": "css, animation",
    "date": "2020-05-13 00:00:00 +0800",
    





    "snippet": "&amp;lt;div class=&quot;flash&quot;&amp;gt;&amp;lt;/div&amp;gt;.flash {  animation: goAway 0.5s ease-in-out forwards;  animation-delay: 2s;}@keyframes goAway {  from {    transform: none;    opacity: 1;  }  to {    transform: tanslateY(-50px);    opacity: 0;  }}"
  },
  
  {
    "title": "자바스크립트 객체 · 배열 병합하기",
    "url": "/posts/2020-05-12-javascript-merge-objects/",
    "categories": "javascript",
    "tags": "javascript",
    "date": "2020-05-12 00:00:00 +0800",
    





    "snippet": "function mergetObjects(obj1, obj2) {  return { ...obj1, ...obj2 };}const obj1 = {  name: &quot;John&quot;,  age: 21,};const obj2 = {  from: &quot;Canada&quot;,};const obj3 = mergetObjects(obj1, obj2);배열의 경우도 사용법은 동일하다."
  },
  
  {
    "title": "자바스크립트 Promise와 Axios",
    "url": "/posts/2020-05-11-javascript-promise-axios/",
    "categories": "javascript",
    "tags": "javascript",
    "date": "2020-05-11 00:00:00 +0800",
    





    "snippet": "Promise가 등장한 이유func(url, function (response1) {  func1(response1, function (response2) {    func2(response2, function (response3) {      ...    });  });});위 코드 예제는 ES6 이전의 콜백 지옥을 흉내내본 것이다. 순차적으로 해결한다는 느낌보다는 옆으로 깊어지는 느낌; 그래서 이러한 비동기 처리를 순차적으로 해결하기 위한 니즈에 따라 등장한게 Promise였다.function getUsers() {  fe..."
  },
  
  {
    "title": "CSS 애니메이션 기본 사용법",
    "url": "/posts/2020-05-11-animation/",
    "categories": "css",
    "tags": "css, animation",
    "date": "2020-05-11 00:00:00 +0800",
    





    "snippet": "적용 원리  animation 속성과 하위 속성을 지정  애니메이션의 중간 상태를 @keyframes 규칙을 이용하여 기술@keyframes애니메이션의 중간 상태 (특정 시점에 Element가 어떻게 보여질지)를 표현하기 위해서는 @keyframes 규칙을 이용해서 2개 이상의 중간 상태를 기술한다.중간 상태가 전체 애니메이션에서 언제 등장할지는 % 수치 또는 from - to를 이용해 표현한다. 0%는 애니메이션이 시작된 시점을 의미하고, 100%는 애니메이션이 끝나는 시점을 의미하며, 최소한 두 시점 (시작과 끝)은 기술되..."
  },
  
  {
    "title": "Socket.io 사용자 로그인과 로그아웃 구현 예제",
    "url": "/posts/2020-05-10-socket-io-user-login-logout/",
    "categories": "node, socket-io",
    "tags": "node, socket-io, express, websocket, javascript",
    "date": "2020-05-10 00:00:00 +0800",
    





    "snippet": "Loginfunction loadNickname() {  const nickname = JSON.parse(localStorage.getItem(LS_NICKNAME));  if (nickname) {    loginUser(nickname);  } else {    setNickname();  }}페이지가 로드될 때, localStorage에 저장된 닉네임이 있는지 확인한다. 저장된 닉네임이 있다면 로그인 처리를 하고, 없다면 닉네임을 입력받는다.저장된 닉네임이 없는 경우function setNickname() {  gues..."
  },
  
  {
    "title": "자바스크립트 URLSearchParams() 사용법",
    "url": "/posts/2020-05-10-javascript-url-search-params/",
    "categories": "javascript",
    "tags": "javascript",
    "date": "2020-05-10 00:00:00 +0800",
    





    "snippet": "URL의 쿼리 파라미터들을 읽거나 수정할 때 사용되는 메소드.const URL = &quot;http://127.0.0.1/search/?keyword=검색어&quot;;const search = location.search;console.log(search); // ?keyword=검색어// URLSearchParams를 사용해 객체로 변환const params = new URLSearchParams(search);console.log(params.get(&quot;keyword&quot;)); // 검색어// 파라미터 값 ..."
  },
  
  {
    "title": "Socket.io 소켓 관련 함수를 하나의 파일로 관리하기",
    "url": "/posts/2020-05-09-group-socket/",
    "categories": "node, socket-io",
    "tags": "node, socket-io, express, websocket, javascript",
    "date": "2020-05-09 00:00:00 +0800",
    





    "snippet": "// src/frontend/login.jsfunction login(nickname) {  // 서버에 연결되는 시점 =&amp;gt; 소켓이 생성되는 시점  const socket = io(&quot;/&quot;);  socket.emit(window.events.setNickname, { nickname });  initSocket(socket);}// src/frontend/socket.jsimport { enterUser, leaveUser } from &quot;./notifications&quot;;import ..."
  },
  
  {
    "title": "자바스크립트 제한적 범위의 난수 만들기",
    "url": "/posts/2020-05-09-javascript-make-limiting-random-number/",
    "categories": "javascript",
    "tags": "javascript",
    "date": "2020-05-09 00:00:00 +0800",
    





    "snippet": "random() 메소드는 0 이상 1 미만의 구간에서 부동소숫점 의사난수를 생성한다. 이는 다음과 같이 활용할 수 있다.0 ~ 지정한 값 사이의 난수 생성function getRandom(max) {  return Math.random() * max;}두 값 사이의 난수 생성function getRandomArbitrary(min, max) {  return Math.random() * (max - min) + min;}두 값 사이의 정수 난수 생성//최댓값은 제외, 최솟값은 포함function getRandomInt(min,..."
  },
  
  {
    "title": "자바스크립트 객체의 구조 분해 (Destructuring) 활용법",
    "url": "/posts/2020-05-08-javascript-destructuring-object-advenced/",
    "categories": "javascript",
    "tags": "javascript",
    "date": "2020-05-08 00:00:00 +0800",
    





    "snippet": "기본 사용법const obj = {  name: &quot;John&quot;,  age: 25,  gender: &quot;male&quot;,  memo: {    work: &quot;software developer&quot;,    hobby: &quot;work out&quot;,  },};const { name, age } = obj;객체에서 각각을 (필요한 것만) 구조 분해해서 let, const 상관없이 새로운 변수에 할당 할 수 있다.중첩 객체 추출const obj = {  name: &quot;John&qu..."
  },
  
  {
    "title": "Socket.io 실시간 채팅 구현 예제 #2",
    "url": "/posts/2020-05-07-socket-io-chatting/",
    "categories": "node, socket-io",
    "tags": "node, socket-io, express, websocket, javascript",
    "date": "2020-05-07 00:00:00 +0800",
    





    "snippet": "설명은 주석으로 대신함.Frontend// src/frontend/chat.jsimport { getSocket } from &quot;./socket&quot;;const chat = document.querySelector(&quot;.chat&quot;);const messages = chat.querySelector(&quot;ul&quot;);const formMessage = chat.querySelector(&quot;form&quot;);export function newMessage({ message, nick..."
  },
  
  {
    "title": "자바스크립트 객체의 구조 분해 (Destructuring)",
    "url": "/posts/2020-05-07-javascript-destructuring-object/",
    "categories": "javascript",
    "tags": "javascript",
    "date": "2020-05-07 00:00:00 +0800",
    





    "snippet": "객체를 구조 분해 할당할 때는 키를 기준으로 한다.const obj = {  name: &quot;John&quot;,  age: 25,  gender: &quot;male&quot;,  memo: {    work: &quot;software developer&quot;,    hobby: &quot;work out&quot;,  },};const { name, age } = obj;2단 중첩 구조의 표현const {  memo: { work, hobby },} = obj;만약 이름을 바꾸고 싶다면 다음과 같이 origin:..."
  },
  
  {
    "title": "Socket.io 실시간 채팅 구현 예제 #1",
    "url": "/posts/2020-05-06-socket-io-real-time-chat/",
    "categories": "node, socket-io",
    "tags": "node, socket-io, express, websocket, javascript",
    "date": "2020-05-06 00:00:00 +0800",
    





    "snippet": "설명은 주석으로 대신함.Server// 서버 연결시 새로운 소켓 생성// 서버는 모든 이벤트에 대해 열려 있음ioServer.on(&quot;connection&quot;, (socket) =&amp;gt; {  // newMessage 이벤트에 대해 듣고 있음  socket.on(&quot;newMessage&quot;, ({ message }) =&amp;gt; {    // 접속자를 제외한 모든 클라이언트에 messageNotication 이벤트를 발생시킴    socket.broadcast.emit(&quot;messa..."
  },
  
  {
    "title": "자바스크립트 배열의 구조 분해 (Destructuring)",
    "url": "/posts/2020-05-06-javascript-destructuring-array/",
    "categories": "javascript",
    "tags": "javascript",
    "date": "2020-05-06 00:00:00 +0800",
    





    "snippet": "각각 새로운 변수에 구조 분해 할당const arr = [1, 2, 3];const [one, two, three] = arr;위 코드는 변수 one, two, three를 생성하고 각각 arr 요소를 순서대로 대입한 것과 같다. 동일한 코드를 구조 분해를 사용하지 않고 표현하면 다음과 같다.const arr = [1, 2, 3];const one = arr[0];const two = arr[1];const three = arr[2];가져올 요소 이외의 변수를 초기화 할 때const arr = [1, 2, 3];const [o..."
  },
  
  {
    "title": "Socket.io 이벤트 컨트롤러 분리하기",
    "url": "/posts/2020-05-05-socket-io-controller/",
    "categories": "node, socket-io",
    "tags": "node, socket-io, express, websocket, javascript",
    "date": "2020-05-05 00:00:00 +0800",
    





    "snippet": "Serverconst PORT = 4000;const app = express();const server = app.listen(PORT, listenPort);const ioServer = socketIO(server);ioServer.on(&quot;connection&quot;, (socket) =&amp;gt; {  // 소켓의 정보가 유실되지 않도록 인자로 전달  socketController(socket);});ioServer는 모든 연결에 대해 (모든 소켓에 대해) 듣고 있다. 이때 위와 같이 내부에서 모든 이벤트..."
  },
  
  {
    "title": "자바스크립트 배열에서 특정 요소만 삭제하기",
    "url": "/posts/2020-05-05-javascript-delete-element/",
    "categories": "javascript",
    "tags": "javascript",
    "date": "2020-05-05 00:00:00 +0800",
    





    "snippet": "Destructuring 활용const user = {  name: &quot;John&quot;,  age: 21,  from: &quot;Canada&quot;,};function delElement({ name, age }) {  return { name, age };}const newUser = delElement(user);// newUser는 name, age만 가지고 있다.Rest Operator 활용const user = {  name: &quot;John&quot;,  age: 21,  from: &quot;C..."
  },
  
  {
    "title": "Socket.io 이벤트와 객체를 하나의 파일로 관리 · 공유하기",
    "url": "/posts/2020-05-04-socket-io-share-object/",
    "categories": "node, socket-io",
    "tags": "node, socket-io, express, websocket, javascript",
    "date": "2020-05-04 00:00:00 +0800",
    





    "snippet": "이벤트를 하나의 객체로 관리하기// src/events.jsconst events = {  enterUser: &quot;enterUser&quot;,  logoutUser: &quot;logoutUser&quot;,};export default events;Socket.io의 이벤트를 한 번에 관리하기 위해서 위 코드 예제와 같이 events.js 파일을 만들고, 파일 내부에 객체를 만들어 export 한다. 이렇게 하면 이벤트 컨트롤러를 작성하는 부분과 이벤트를 감시하는 부분 모두 이벤트 이름을 하드 코딩 하지않고 객체로 ..."
  },
  
  {
    "title": "자바스크립트 링크 클릭 발생 시키기",
    "url": "/posts/2020-05-04-javascript-anchor-fake-click/",
    "categories": "javascript",
    "tags": "javascript",
    "date": "2020-05-04 00:00:00 +0800",
    





    "snippet": "const a = document.createElement(&quot;a&quot;);a.href = url;a.download = &quot;image.jpg&quot;;document.body.appendChild(a);a.click();어떤 링크로 연결해서 파일을 다운로드 할 수 있게끔 하기 위해서, 해당 URL을 가리키는 a 태그를 만들고, click() 함수를 사용해서 가짜 클릭을 발생시킨다."
  },
  
  {
    "title": "자바스크립트 마우스 오른쪽 클릭 (Context Menu) 이벤트 처리",
    "url": "/posts/2020-05-03-javascript-right-click/",
    "categories": "javascript",
    "tags": "javascript",
    "date": "2020-05-03 00:00:00 +0800",
    





    "snippet": "function blockRightClick(event) {  event.preventDefault();}cavas.addEventListener(&quot;contextmenu&quot;, blockRightClick);마우스 우클릭시 나오는 창을 Context Menu라고 부르며, 이벤트 처리를 통해 마우스 우클릭을 방지하거나 임의의 이벤트를 지정할 수 있다."
  },
  
  {
    "title": "Socket.io 이벤트를 다루는 방법",
    "url": "/posts/2020-05-02-socket-io-events/",
    "categories": "node, socket-io",
    "tags": "node, socket-io, express, websocket, javascript",
    "date": "2020-05-02 00:00:00 +0800",
    





    "snippet": "이벤트의 동작과 처리  서버와 클라이언트는 이벤트를 듣고 있음.  이벤트 발생시 듣고 있던 서버 / 클라이언트가 반응.// ioServer는 모든 이벤트를 감시하고 있어야 함// connection 이벤트에 대해 듣고 있음// 새로운 연결이 생성되면 새로운 소켓이 생성 됨ioServer.on(&quot;connection&quot;, (socket) =&amp;gt; {  // 접속한 소켓을 제외한 모든 클라이언트에 enterUser 이벤트 전송  socket.broadcast.emit(&quot;enterUser&quot;)..."
  },
  
  {
    "title": "자바스크립트 다른 파일에 있는 객체 (배열) 사용하기",
    "url": "/posts/2020-05-02-javascript-export-module/",
    "categories": "javascript",
    "tags": "javascript",
    "date": "2020-05-02 00:00:00 +0800",
    





    "snippet": "클라이언트 사이드 (브라우저)에서 자바스크립트를 사용할 때, 다른 파일에 있는 객체나 배열을 사용하기 위해서는 스크립트 파일을 module로 등록하고 import, export를 사용해 객체나 배열을 가져와 사용한다.&amp;lt;script type=&quot;module&quot; src=&quot;./src/index.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;script src=&quot;./src/movies.js&quot;&amp;gt;&amp;lt;/script&amp;gt..."
  },
  
  {
    "title": "Socket.io 동작 이해",
    "url": "/posts/2020-05-01-how-to-work-socket-io/",
    "categories": "node, socket-io",
    "tags": "node, socket-io, express, websocket, http, javascript",
    "date": "2020-05-01 00:00:00 +0800",
    





    "snippet": "Socket.io를 사용한다는 것은 Express 서버 위에 Socket.io (WebSocket) 서버를 올린다는 의미이다. 전통적인 (?) 방식에서, 2개의 서버가 같은 포트에서 동작하게 할 수 없지만, WebSocket과 HTTP는 같은 공생이 가능하다.Express 서버 위에 Socket.io 서버를 올리는 방법import express from &quot;express&quot;;import socketIO from &quot;socket.io&quot;;const PORT = 4000;const app = expre..."
  },
  
  {
    "title": "자바스크립트 Array.prototype.toLocaleString()",
    "url": "/posts/2020-05-01-javascript-array-toLocaleString/",
    "categories": "javascript",
    "tags": "javascript",
    "date": "2020-05-01 00:00:00 +0800",
    





    "snippet": "toLocaleString() 메소드는 요소를 문자열로 변환하고, 지정한 문화권 (나라)의 표기법에 따라 시간, 화폐 등을 고유 문자열로 분리한다. 다음과 같은 상황에서 사용할 수 있다.  1000단위 (화폐) 쉼표 넣기  문화권 시간 표기법에 따른 변환const price = 10000;const message = `￦${price.toLocaleString(&quot;ko-KR&quot;)}`;// message = &quot;￦10,000&quot;"
  },
  
  {
    "title": "자바스크립트 Array.prototype.map()",
    "url": "/posts/2020-04-28-javascript-array-map/",
    "categories": "javascript",
    "tags": "javascript",
    "date": "2020-04-28 00:00:00 +0800",
    





    "snippet": "map() 메소드는 배열의 각 요소에 주어진 함수를 실행한 결과를 새로운 배열로 리턴한다. 보통 for문을 돌려서 새로운 배열을 만드는 것을 목적으로 사용한다.Array.map(callBack[, thisArg])  callBack : function (currentValue[, index][, originArray])          currentValue : 현재 값      index : 현재 인덱스      originArray : 원본 배열        tihsArg : this에 할당할 대상 (생략시 global 객..."
  },
  
  {
    "title": "자바스크립트 Array.prototype.reduce()",
    "url": "/posts/2020-04-27-javascript-array-reduce/",
    "categories": "javascript",
    "tags": "javascript",
    "date": "2020-04-27 00:00:00 +0800",
    





    "snippet": "reduce() 메소드는 배열의 각 요소에 대해 reducer() 함수를 실행하고, 최종 결과를 리턴한다. for문을 돌려서 최종적으로 다른 무엇인가를 만드는 목적으로 사용한다.Array.reduce(callBack[, initValue])  callBack : function (accumulator, currentValue, currentIndex[, originArray])          accumulator : 누적된 계산 값      currentValue : 현재 값      currentIndex : 현재 인덱스 ..."
  },
  
  {
    "title": "자바스크립트 Array.prototype.forEach()",
    "url": "/posts/2020-04-26-javascript-array-forEach/",
    "categories": "javascript",
    "tags": "javascript",
    "date": "2020-04-26 00:00:00 +0800",
    





    "snippet": "forEach() 메소드는 배열 요소 각각에 인자로 받은 함수를 실행한다.Array.forEach(callBack[, thisArg])  callBack : function (currentValue[, index][, originarray])          currentValue : 현재 값      index : 현재 인덱스      originArray : 원본 배열        thisArg : this에 할당할 대 (생략시 global 객체)const arr = [1, 2, 3];arr.forEach((value, i..."
  },
  
  {
    "title": "자바스크립트 Array.prototype.find() · findIndex()",
    "url": "/posts/2020-04-25-javascript-array-find-findIndex/",
    "categories": "javascript",
    "tags": "javascript",
    "date": "2020-04-25 00:00:00 +0800",
    





    "snippet": "find()const arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];arr.find((char) =&amp;gt; char === &quot;a&quot;); // &quot;a&quot;arr.find((char) =&amp;gt; char === &quot;d&quot;); // undefinedindexOf()와 비슷하지만 인자로 함수를 받는 메소드. 값이 존재하지 않을 때 undefined를 출력한다.findIndex()const arr = [&quot;a&quot;, &q..."
  },
  
  {
    "title": "자바스크립트 Array.prototype.from()",
    "url": "/posts/2020-04-24-javascript-array-from/",
    "categories": "javascript",
    "tags": "javascript",
    "date": "2020-04-24 00:00:00 +0800",
    





    "snippet": "Array.from() 메소드를 사용하면 유사 배열 객체나 반복 가능한 객체를 얕은 복사해서 새로운 배열 객체를 만든다.const arr = [1, 2, 3, 4, 5];const newArr = Array.from(arr).map((number) =&amp;gt; {  return (number += 1);}); // newArr = [2, 3, 4, 5, 6]"
  },
  
  {
    "title": "자바스크립트 Array.prototype.filter()",
    "url": "/posts/2020-04-23-javascript-array-filter/",
    "categories": "javascript",
    "tags": "javascript",
    "date": "2020-04-23 00:00:00 +0800",
    





    "snippet": "filter() 메소드는 인자로 주어진 함수의 조건을 통과하는 요소를 모아서 새로운 배열로 리턴한다.const numbers = [2, 4325, 123, 4, 635, 66, 7756, 31, 7];const biggerThan1000 = numbers.filter((number) =&amp;gt; number &amp;gt; 1000);// biggerThan1000 = [4325, 7756]조건을 만족하는 원소만 결과만 추출.let titles = [&quot;untitled&quot;, &quot;hello&quot;,..."
  },
  
  {
    "title": "자바스크립트 Array.prototype.fill()",
    "url": "/posts/2020-04-22-javascript-array-fill/",
    "categories": "javascript",
    "tags": "javascript",
    "date": "2020-04-22 00:00:00 +0800",
    





    "snippet": "fill() 메소드는 배열의 시작 인덱스부터 끝 인덱스의 이전 (바로 앞) 인덱스까지 특정 값으로 채운다.const arr = [1, 2, 3, 4, 5];arr.fill(10);// arr = [10, 10, 10, 10, 10];인자로 채울 값만 넘겼을 경우, 전체를 지정한 값으로 다 채운다.arr.fill(20, 2, 4);// arr = [10, 10, 20, 20, 10]인자로 시작 값과 끝 값을 지정한 경우에는 시작 인덱스부터 끝 인덱스의 바로 ‘앞’ 인덱스 (2 ~ 3) 까지만 채워진다.arr.fill(30, 2)..."
  },
  
  {
    "title": "모던 자바스크립트와 ES6 #11 async · await",
    "url": "/posts/2020-04-19-es6-syntax-21-async-await/",
    "categories": "javascript",
    "tags": "javascript, es6",
    "date": "2020-04-19 00:00:00 +0800",
    





    "snippet": "ES5까지의 비동기 처리는 에러 처리가 힘들고 콜백 지옥같은 문제가 있어서, ES6에서는 Promise를 도입했다. 하지만 Promise를 사용하더라도 여전히 코드가 길어지는 것은 해결할 수 없었고, 이러한 점들을 보완하기 위해서 ES8에서 asnyc와 await이 도입되었다.  async와 await을 비동기 처리에서 절대적으로 사용해야하는 것은 아니다. 콜백의 Depth가 얕은 경우에는 그냥 Promise를 사용하는것이 더 간결한 코드 작성법이 될 때도 있다.(async function func() {  await msg(..."
  },
  
  {
    "title": "모던 자바스크립트와 ES6 #10 Generator",
    "url": "/posts/2020-04-19-es6-syntax-20-generator/",
    "categories": "javascript",
    "tags": "javascript, es6",
    "date": "2020-04-19 00:00:00 +0800",
    





    "snippet": "Generator는 Generator Function의 리턴 값으로, Iterable Protocol과 Iterator Protocol을 따르는 객체이다. 이때 Generator Function은 함수를 실행하면 내부에 정의된 처리를 함수의 끝까지 한 번에 실행하는 일반 함수와 달리, yield와 next() 등을 사용해 특정 시점에 멈출 수도 있고, 다시 시작될 수도 있으며, 상황에 따라 여러 값을 리턴할 수도 있는 함수이다.function* genFunction() {  yield 100;  yield 200;  yield..."
  },
  
  {
    "title": "모던 자바스크립트와 ES6 #9 Promise",
    "url": "/posts/2020-04-19-es6-syntax-19-promise/",
    "categories": "javascript",
    "tags": "javascript, es6",
    "date": "2020-04-19 00:00:00 +0800",
    





    "snippet": "자바스크립트에서는 비동기 처리를 위해 일반적으로 콜백 함수를 사용한다. 하지만 기존의 콜백 패턴이 굉장히 지저분했고 예외 처리가 어려웠기 때문에, 여러 개의 비동기 처리를 한 번에 처리하려면 콜백 지옥이 열리곤 했다.first(function (a) {  second(function (b) {    third(function (c) {      fourth(function (d) {        // codes ...      });    });  });});이러한 문제점을 보완하기 위해서 ES6에서는 Promise라는 개념을..."
  },
  
  {
    "title": "모던 자바스크립트와 ES6 #8 Module",
    "url": "/posts/2020-04-19-es6-syntax-18-module/",
    "categories": "javascript",
    "tags": "javascript, es6",
    "date": "2020-04-19 00:00:00 +0800",
    





    "snippet": "대부분의 프로그래밍 언어는 각자의 모듈 기능을 가지고 있다. 예를 들어 C언어의 경우 #include를 사용해 외부의 모듈을 가져온다. 클라이언트 사이드의 자바스크립트의 경우, &amp;lt;script&amp;gt; 태그를 사용해서 외부의 모듈 (스크립트 파일)을 가져올 수 있다. 하지만 이 경우 파일 단위로 독자적인 Scope를 가지는 것이 아니라 하나의 전역 객체를 공유한다는 특징이 있다. 즉, 이렇게 &amp;lt;script&amp;gt; 태그로 모듈을 가져오는 경우 모듈화를 구현할 수는 없다.  서버 사이드 자바스크..."
  },
  
  {
    "title": "모던 자바스크립트와 ES6 #7 Destructuring Assignment",
    "url": "/posts/2020-04-19-es6-syntax-17-destructuring/",
    "categories": "javascript",
    "tags": "javascript, es6",
    "date": "2020-04-19 00:00:00 +0800",
    





    "snippet": "Destructuring Assignment Syntax는 배열이나 객체를 Destructuring (비구조화)해서 각각의 요소를 개별적인 변수에 할당하는 것을 의미하며, 일반적으로 구조화된 배열이나 객체에서 특정 값만을 꺼내 변수에 할당하거나 리턴하기 위해 사용된다.  추천 글 : Destructuring Assignment - MDNArray Destructuringarr에 들어있는 요소를 각각의 변수에 할당하고자 하는 경우를 가정해보자.var arr = [&quot;John&quot;, &quot;Thomas&quot;,..."
  },
  
  {
    "title": "모던 자바스크립트와 ES6 #6 Enhanced Object Literals",
    "url": "/posts/2020-04-19-es6-syntax-16-object-initailizer/",
    "categories": "javascript",
    "tags": "javascript, es6",
    "date": "2020-04-19 00:00:00 +0800",
    





    "snippet": "ES6에서는 향상된 객체의 Literal을 제공한다. 이는 ES5까지의 객체 정의 방식을 개선한 문법을 의미하며, 객체를 정의하거나 객체 내 메소드를 정의하는 등 자주 사용되는 문법들을 좀 더 간결하게 사용할 수 있다.Property ShorthandES6에서는 Props 값으로 변수를 사용할 때, Property 이름을 생략할 수 있는 축약 표현을 제공한다.const name = &quot;John&quot;;const age = 20;const obj = {  name,  age,};console.log(obj);Metho..."
  },
  
  {
    "title": "모던 자바스크립트와 ES6 #5 Spread Syntax",
    "url": "/posts/2020-04-19-es6-syntax-15-spread/",
    "categories": "javascript",
    "tags": "javascript, es6",
    "date": "2020-04-19 00:00:00 +0800",
    





    "snippet": "Spread Syntax (...)는 점 뒤에 오는 대상을 개별 요소로 분리한다. 이때 대상은 Iterable 해야 한다.const arr = [1, 2, 3];console.log(...arr, 4, 5);이를 응용해 배열을 파라미터로 함수에 전달하고자 할 때, 모든 요소를 분리해서 순차적으로 전달할 수 있다.function sum(a, b, c) {  return a + b + c;}const arr = [1, 2, 3];console.log(sum(...arr));사용 예시다음 코드는 arr1에 arr2의 각각의 요소를 ..."
  },
  
  {
    "title": "모던 자바스크립트와 ES6 #4 Default · Rest Parameter",
    "url": "/posts/2020-04-19-es6-syntax-14-default-rest-parameter/",
    "categories": "javascript",
    "tags": "javascript, es6",
    "date": "2020-04-19 00:00:00 +0800",
    





    "snippet": "Default Parameter Value자바스크립트에서는 함수를 호출할 때 요구되는 파라미터의 개수가 부족한 경우에도 에러가 발생하지 않는다. 예를 들어 다음의 경우를 가정해보자.function sum(a, b) {  return a + b;}console.log(sum(10));sum() 함수는 2개의 아규먼트를 사용하게끔 정의되어 있지만, 호출할 때 하나의 파라미터만 전달해도 에러가 발생하지 않는다. 즉, 함수가 파라미터 개수나 아규먼트 개수를 체크하지 않는다. 이렇게 아규먼트가 부족한 경우에 그 값은 undefined이..."
  },
  
  {
    "title": "모던 자바스크립트와 ES6 #3 Arrow Function",
    "url": "/posts/2020-04-19-es6-syntax-13-arrow-function/",
    "categories": "javascript",
    "tags": "javascript, es6",
    "date": "2020-04-19 00:00:00 +0800",
    





    "snippet": "Arrow Function (이하 화살표 함수)는 ES6에서 도입된, function 키워드를 사용하지 않아도 =&amp;gt; 화살표를 사용함으로써 보다 간단하게 함수를 선언할 수 있는 문법이다. 화살표 함수의 사용법은 매우 간단하지만, 다음과 같은 몇 가지 규칙이 있다.// 1. 아규먼트가 없을 경우 () 괄호 생략 불가() =&amp;gt; {};// 2. 아규먼트가 한 개일 때는 괄호를 생략해도 되지만, 2개 이상이면 괄호를 생략할 수 없음(a, b) =&amp;gt; {};// 3. 함수의 몸체가 Single Line..."
  },
  
  {
    "title": "모던 자바스크립트와 ES6 #2 Template Literals",
    "url": "/posts/2020-04-19-es6-syntax-12-template-literal/",
    "categories": "javascript",
    "tags": "javascript, es6",
    "date": "2020-04-19 00:00:00 +0800",
    





    "snippet": "ES5까지, 일반 텍스트와 변수를 하나의 문자열로 사용하려면 다음과 같이 했어야 했다.var a = 1;var b = 2;console.log(&quot;a is &quot; + a + &quot; and b is &quot; + b);알다시피 이런 방식은 귀찮다. 단호하게 귀찮다.const a = 1;const b = 2;console.log(`a is ${a} and b is ${b}`);ES6에서는 새로운 문자열 표기법인 Backtick을 사용할 수 있게 되었는데, 이 문자열로 감싼 내부에는 위 코드와 같이 변수를 직접적..."
  },
  
  {
    "title": "모던 자바스크립트와 ES6 #1 var · let · const",
    "url": "/posts/2020-04-19-es6-syntax-11-let-const/",
    "categories": "javascript",
    "tags": "javascript, es6",
    "date": "2020-04-19 00:00:00 +0800",
    





    "snippet": "var의 문제점ES5까지의 자바스크립트에서는 변수를 선언할 때 var 키워드를 사용했다. (물론 지금도 사용할 수 있지만 그때는 유일했다.) var 키워드는 특성상 문제를 야기할 가능성이 높았는데, 그 특성에 대한 내용은 다음과 같다.var a = 1;var b = 2;console.log(a); // 1console.log(b); // 2{  var a = 2;  var b = 3;}console.log(a); // 2console.log(b); // 3첫 번째로, 변수 중복 선언이 허용된다. 즉, 실수로 a라는 변수를 두 ..."
  },
  
  {
    "title": "자바스크립트 레벨업을 위한 주요 개념 #4 Higher Order Function",
    "url": "/posts/2020-04-18-js-level-up-4-higher-order-function/",
    "categories": "javascript",
    "tags": "javascript, hof",
    "date": "2020-04-18 00:00:00 +0800",
    





    "snippet": "Higher Order Function (HOF, 고차 함수)는 함수를 리턴하거나 함수를 파라미터로 전달받는 함수를 의미하며, 넘겨받은 함수를 호출하거나 클로저로 리턴하는 역할을 한다. 이게 가능한 이유는 자바스크립트의 함수가 First Class이기 때문인데, 더 자세한 내용은 MDN의 First Class Function 문서를 참고하자.이러한 고차 함수를 사용하는 이유는 함수형 프로그래밍 지향을 위해서, 데이터가 Mutate 되는 것을 최대한 피하고자 하기 때문이다. 즉, 함수형 프로그래밍은 Pure Function + ..."
  },
  
  {
    "title": "자바스크립트 레벨업을 위한 주요 개념 #3 this",
    "url": "/posts/2020-04-18-js-level-up-3-function-this-bind/",
    "categories": "javascript",
    "tags": "javascript, this",
    "date": "2020-04-18 00:00:00 +0800",
    





    "snippet": "자바스크립트에서는 어떤 함수가 호출될 때 전달되는 아규먼트 말고도 arguments라는 객체와 this가 은밀하게 (?) 전달되고 있다. this는 아마도 Java를 배워본적 있는 사람이라면 꽤 낯이 익는 친구일 것이다. 하지만 이때 this는 Java의 this와는 개념적으로 다른데, Java에서는 자기 자신의 Reference를 가르키는 변수로써 사용되지만, 자바스크립트에서는 함수를 호출하는 방식에 따라 this에 바인딩되는 객체가 달라진다.함수 호출 방식에 따른 this 바인딩자바스크립트에서 Lexical Scope는 함..."
  },
  
  {
    "title": "자바스크립트 레벨업을 위한 주요 개념 #2 Closure",
    "url": "/posts/2020-04-18-js-level-up-2-closure/",
    "categories": "javascript",
    "tags": "javascript, closure",
    "date": "2020-04-18 00:00:00 +0800",
    





    "snippet": "Closure (이하 클로저)는 자바스크립트에 한정되는 개념은 아니고, Functional Programming Language에서 다루는 주요한 특성 중 하나이다. 이 개념은 리턴된 함수가 리턴되기 전에 가진 Scope를 리턴된 다음에도 접근할 수 있는 함수를 의미한다. 즉, 클로저는 자기 자신이 생성될 때의 Lexical Environment를 기억하고 접근할 수 있는 함수라고 정의할 수 있다.function first() {  const greating = &quot;Hello World!&quot;;  const sec..."
  },
  
  {
    "title": "자바스크립트 레벨업을 위한 주요 개념 #1 Scope와 Scope Chain",
    "url": "/posts/2020-04-18-js-level-up-1-scope-chain/",
    "categories": "javascript",
    "tags": "javascript, scope",
    "date": "2020-04-18 00:00:00 +0800",
    





    "snippet": "변수나 함수는 각각의 유효한 Scope를 가지고 있다. Block Level Scope란 하나의 블록 {} 내부에서 선언된 변수는 해당 블록 내부에서만 유효하다는 규칙이며, Function Level Scope의 경우 함수 내부에서 선언된 변수는 함수 내부에서만 유효하다는 규칙이다.Lexical Scope자바스크립트의 Scope에 대해 좀 더 깊이 이해하기 위해 알아야 할 또 하나의 개념은 Lexical Scope (Static Scope)라는 규칙이다. Lexical Scope는 코드가 작성된 문맥상에서 결정되는 Scope로..."
  },
  
  {
    "title": "CSS 뷰포트 사이즈 단위 vh · vw · vmin · vmax 정리",
    "url": "/posts/2020-03-20-vh-vw-vmin-vmax/",
    "categories": "css",
    "tags": "css, animation",
    "date": "2020-03-20 00:00:00 +0800",
    





    "snippet": "vh · vwvh (Vertical Height)과 vw (Vertical Width) 단위는 뷰포트 높이 및 너비에 맞게 타겟 요소의 크기를 지정하고자 할 때 사용된다.body {  height: 100vh;}vh 요소는 높이 값의 1 / 100 단위이다. 즉, 뷰포트 높이 값이 1000px일 때 1vh는 10px이 되기 때문에, 100vh는 뷰포트 (브라우저 높이 값)의 100%에 해당된다. (vw의 경우에도 세로가 아니라 가로를 의미하는 것 외에는 동일하다.)vmin · vmaxvh와 vw 단위가 뷰포트의 높이 및 너비 ..."
  },
  
  {
    "title": "GitHub 저장소에서 파일 삭제하는 방법",
    "url": "/posts/2020-03-12-github-remove-file/",
    "categories": "git",
    "tags": "git, github",
    "date": "2020-03-12 00:00:00 +0800",
    





    "snippet": "GitHub에 파일 잘못올린 경우 다음과 같은 흐름으로 작업하여, 이미 원격 저장소에 올라간 파일을 삭제할 수 있다.  .gitignore 작성  원격 저장소에서 파일 삭제  원격 저장소에 적용원격 저장소에서 파일 삭제# 원격 저장소의 index.html 파일 삭제git rm --cached index.html# src/style.css 파일 삭제git rm --cached src/style.css# src 폴더 하위 모두 삭제git rm --cached -r src/위 명령어로 원격 저장소에 잘못 올라간 파일만 삭제한다. 이..."
  },
  
  {
    "title": "GitHub 여러 개의 Issue 한 번에 처리 (Close)하는 방법",
    "url": "/posts/2020-03-11-github-more-than-two-issue/",
    "categories": "git",
    "tags": "git, github",
    "date": "2020-03-11 00:00:00 +0800",
    





    "snippet": "git checkout -b &quot;issue-11&quot;이슈 해결을 위한 브랜치를 생성한다.git add .git commit -m &quot;Edit Documents (#12, #14)&quot;해당 브랜치에서 작업 후, add 및 commit 하고, Pull Request를 보내기 위해 Upstream으로 push 한다.- Close #12- Close #14Pull Request Comment에 해결된 이슈들을 키워드와 함께 작성한다. close 외에도 자동 이슈 처리를 위해서 사용할 수 있는 키워드는 다음과 ..."
  },
  
  {
    "title": "GitHub Issue 생성과 Pull Request 처리 방법",
    "url": "/posts/2020-03-10-github-issue-pull-request/",
    "categories": "git",
    "tags": "git, github",
    "date": "2020-03-10 00:00:00 +0800",
    





    "snippet": "이슈 생성과 처리의 흐름  Issue 생성  Branch 생성  Pull Request  Merge (Issue 처리)이슈 생성시 추가할 수 있는 항목  Assignees : 이슈 담당자  Labels : 카테고리  Milestone : 소속 파트 (예 : Version 1.0.0)Branch 생성# Branch 생성 후 Checkoutgit checkout -b issue-1이슈 처리를 위한 브랜치 생성.Pull Requestgit add .git commit -m &quot;Edit README.md (#12)&quot;작..."
  },
  
  {
    "title": "Git 상태 및 파일 복원을 위한 reset · revert · checkout 사용법",
    "url": "/posts/2020-03-08-git-revert-reset-checkout/",
    "categories": "git",
    "tags": "git",
    "date": "2020-03-08 00:00:00 +0800",
    





    "snippet": "상태 복원복원은 현재 파일을 특정한 시점의 파일 상태로 변경하는 작업을 의미한다. 이와 같은 복원을 위해 사용되는 대표적인 명령어들은 다음과 같다.  reset  revert  checkoutresetreset은 Staged (Tracked) 상태의 파일이나 커밋된 파일을 취소할 때 (이전 상태로 되돌릴 때) 사용되며, 커밋되지 않는다. (커밋되지 않기 때문에 push를 reset으로 취소했다가 다시 하려면 반드시 다시 커밋 해야 한다.)  add, commit, push 취소하기특징reset은 진행된 커밋 이전의 커밋으로 H..."
  },
  
  {
    "title": "Git Add · Commit · Push 취소 방법",
    "url": "/posts/2020-03-07-git-cancle-add-commit-push/",
    "categories": "git",
    "tags": "git, github",
    "date": "2020-03-07 00:00:00 +0800",
    





    "snippet": "git add 취소git add 명령을 취소한다는 것은, Staging Area에 있는 Tracked 파일을 Untracked (Unstage) 상태로 변경하는 것을 의미한다.# git add 한 파일 전체 취소$ git reset HEAD# 특정 파일만 취소$ git reset HEAD index.htmlcommit message 변경$ git commit --amend &quot;Message&quot;git commit 취소# commit 목록 확인$ git log$ git reset --soft HEAD^위 명령어는 커..."
  },
  
  {
    "title": "Git Branch 분기와 병합 예제 (--no--ff 사용법)",
    "url": "/posts/2020-03-04-git-branch-strategy/",
    "categories": "git",
    "tags": "git",
    "date": "2020-03-04 00:00:00 +0800",
    





    "snippet": "로그인 기능을 개발하는 과정을 가정해보자.# -b : 브랜치 생성# git checkout -b 생성할-브랜치 베이스-브랜치git checkout -b feature/login develop로그인 기능 개발을 위해 develop 브랜치에서 분기하는 feature/login 브랜치를 생성하고, 작업 브랜치를 feature/login 브랜치로 변경한다.git add .git commit -m &quot;feat: 로그인 기능 추가&quot;# develop 브랜치로 작업 브랜치 변경git checkout develop# featu..."
  },
  
  {
    "title": "Git Branch 관련 명령어 정리",
    "url": "/posts/2020-03-03-git-branch-commands/",
    "categories": "git",
    "tags": "git",
    "date": "2020-03-03 00:00:00 +0800",
    





    "snippet": "브랜치 확인# 브랜치 확인$ git branch# 브랜치 상세 정보까지 확인$ git branch -v브랜치 상태 확인# Merged 상태 브랜치 확인$ git branch --merged# Merged 되지 않은 브랜치 확인$ git branch --no-merged브랜치 생성$ git branch newBranch baseBranch브랜치 삭제$ git branch -d newBranch브랜치 이동$ git checkout newBranch브랜치 생성과 이동 숏컷$ git checkout -b newBranch baseBr..."
  },
  
  {
    "title": "Git Branch 기본 이해",
    "url": "/posts/2020-03-02-git-branch/",
    "categories": "git",
    "tags": "git",
    "date": "2020-03-02 00:00:00 +0800",
    





    "snippet": "Branch  버전 관리 시스템의 기본  Origin 코드와 별개로 독립된 개발을 진행하기 위해 사용맨 처음 커밋을 할 때, Git은 master (main)라는 이름을 가진 브랜치를 만들고 자동으로 가장 마지막 커밋을 가리키게 (포인터같이) 한다. 다음과 같은 상황을 가정해보자.  최초 커밋  develop이라는 브랜치 생성이때 새로 만든 브랜치 develop도 마지막 커밋을 가리킨다.HEADGit에서 현재 작업 중인 브랜치를 구분할 수 있는 것은 HEAD라는 일종의 포인터가 있기 때문이다. HEAD는 로컬에서 지금 작업하고..."
  },
  
  {
    "title": "GitHub Release 방법",
    "url": "/posts/2020-03-01-github-release/",
    "categories": "git",
    "tags": "git, github",
    "date": "2020-03-01 00:00:00 +0800",
    





    "snippet": "새로운 버전 릴리즈하는 방법릴리즈란 개발 중인 프로젝트가 배포 준비가 되었을 때 (Alpha / Beta / Major) 패키지를 배포하는 것을 의미한다. GitHub에서 릴리즈하기 위해서는 저장소 페이지의 사이드바에서 Create a new release 버튼을 클릭하고, 다음을 참조하여 항목을 채운다.Tag Version  v1.0  v2.3.4  v0.2-alpha  v5.9-betaRelease Title  Version 1.0.2  Something App v1.0  Hello World v2.0-alpha  Show..."
  },
  
  {
    "title": "Git 버전 관리의 Flow 이해",
    "url": "/posts/2020-03-01-git-flow/",
    "categories": "git",
    "tags": "git",
    "date": "2020-03-01 00:00:00 +0800",
    





    "snippet": "Git 작업 흐름Git은 파일을 세 가지 상태로 관리한다.  Commited  Modified  StagedCommited란 데이터 (파일)가 로컬 저장소에 저장된 상태를 의미하고, Modified는 파일을 수정했지만 아직 Staging Area에 추가하지 않은 상태를 의미하며, Staged는 수정한 파일을 Staging Area에 추가한 상태를 의미한다.Staging AreaStaging Area는 곧 커밋할 파일에 대한 정보를 저장한다. 수정한 파일은 git add 명령을 사용해 Staging 상태로 만들 수 있으며, gi..."
  },
  
  {
    "title": "Git Commit 기본 이해",
    "url": "/posts/2020-03-01-git-commit/",
    "categories": "git",
    "tags": "git",
    "date": "2020-03-01 00:00:00 +0800",
    





    "snippet": "Commit  작업에 이력을 기록해서 저장소로 올리는 것  Staging Area에 있는 Tracked 파일들을 저장소에 저장즉, git add 한 파일은 버전 관리되고 있는 파일 (Tracked)git commit$ git add .$ git commit -m &quot;Message&quot;# Shortcut: git commit -am &quot;Message&quot;git diff# Untracked 파일의 변경사항을 보여줌$ git diff# Tracked (커밋 대기) 파일의 변경사항을 보여줌$ git diff ..."
  },
  
  {
    "title": "React Emotion 글로벌 공통 스타일 적용하기",
    "url": "/posts/2020-01-08-react-emotion-global-style/",
    "categories": "react, css-in-js",
    "tags": "react, error, emotion, css-in-js",
    "date": "2020-01-08 00:00:00 +0800",
    





    "snippet": "먼저 글로벌로 적용하려는 스타일을 작성한다.import { css } from &quot;@emotion/react&quot;;const reset = css`  * {    margin: 0;    padding: 0;    box-sizing: border-box;  }`;export default reset;App() 컴포넌트에서 작성한 스타일 파일과 (예시에서는 Reset.tsx) @emotion/react의 Global 컴포넌트를 import한다.import React from &quot;react&quot;;impo..."
  },
  
  {
    "title": "React Emotion TS2322: Property &#39;css&#39; does not exist 에러 해결 방법",
    "url": "/posts/2020-01-08-react-emotion-error-ts2322/",
    "categories": "react, css-in-js",
    "tags": "react, error, emotion, css-in-js",
    "date": "2020-01-08 00:00:00 +0800",
    





    "snippet": "증상타입스크립트로 세팅된 리액트에서 @emotion/react를 사용하려고 할 때, css를 사용할 수 없는 경우 (i.g., 정상적으로 import되지 않는 경우) 다음과 같은 에러 메시지가 출력된다.Type &#39;{ children: Element[]; css: SerializedStyles; }&#39; is not assignable to type &#39;DetailedHTMLProps&amp;lt;HTMLAttributes&amp;lt;HTMLElement&amp;gt;, HTMLElement&amp;gt;&#3..."
  },
  
  {
    "title": "navigator.geolocation 동작하지 않는 경우 해결 방법",
    "url": "/posts/2020-01-07-error-report-chrome-navigator-geolocation/",
    "categories": "javascript",
    "tags": "javascript, error, chrome, https, localhost, navigator, geolocation",
    "date": "2020-01-07 00:00:00 +0800",
    





    "snippet": "증상navigator.geolocation.getCurrentPosition() 메소드 동작하지 않는 경우. (정확히는 동작하지 않는 것처럼 보임.) 웹 페이지가 로드되면 위치 정보 사용을 묻는 팝업은 정상적으로 뜨고, 취소를 눌렀을 때 errorCallBack은 동작하지만 successCallBack은 내부 로직은 동작하지 않는 경우.원인 분석우선 errorCallBack 함수는 동작한다는 점에서, 메소드가 아예 동작하지 않는 것은 아니고 위치 정보 사용 허용을 눌렀을 때 successCallBack 함수가 실행은 되지만 위..."
  }
  
]

