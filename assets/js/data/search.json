[
  
  {
    "title": "타입스크립트 Less · Default Parameter",
    "url": "/posts/2021-06-15-typescript-less-parameter/",
    "categories": "typescript",
    "tags": "typescript",
    "date": "2021-06-15 00:00:00 +0800",
    





    "snippet": "선택적 파라미터function greeting(name, age, gender) {  console.log(`Hello ${name}, you are ${age}, you are a ${gender}`);}greeting(name, age);// Hello stranger, you are 24, you are a undefined위 자바스크립트 예시에서, 함수 greeting은 3개의 인자를 사용하도록 선언되어있지만, 호출시 2개의 파라미터만 넘겨도 실행된다.index.ts:9:1 - error TS2554: Expected ..."
  },
  
  {
    "title": "타입스크립트 .eslintrc 파일 Parsing Error 해결 방법",
    "url": "/posts/2021-06-14-tslint-error/",
    "categories": "typescript",
    "tags": "typescript, error, eslint",
    "date": "2021-06-14 00:00:00 +0800",
    





    "snippet": "증상.eslintrc.js 파일에 타입스크립트 (과거 .tslint) 설정을 할 때 발생하는 Parsing Error 또는 .eslintrc.js 파일 에러.parsing error: &quot;parseroptions.project&quot; has been set for @typescript-eslint/parser. the file does not match your project config: .eslintrc.js. the file must be included in at least one of the projects..."
  },
  
  {
    "title": "Webpack SASS (SCSS) 사용법",
    "url": "/posts/2021-04-05-scss-css-loader/",
    "categories": "webpack",
    "tags": "webpack, javascript, scss",
    "date": "2021-04-05 00:00:00 +0800",
    





    "snippet": "설치npm install sass -Dnpm install sass-loader -Dnpm install css-loader -Dnpm install mini-css-extract-plugin -D각각의 라이브러리가 하는 역할은 다음과 같다.  sass-loader : SCSS 파일을 CSS 파일로 변환  css-loader : CSS 파일을 읽음  mini-css-extract-plugin : 한 파일로 묶음설정const miniCssExtractPlugin = require(&quot;mini-css-extract-plug..."
  },
  
  {
    "title": "Webpack 여러 개의 Entry Point 지정하기",
    "url": "/posts/2021-04-04-entry-file-name/",
    "categories": "webpack",
    "tags": "webpack, javascript",
    "date": "2021-04-04 00:00:00 +0800",
    





    "snippet": "module.exports = {  entry: {    // 다수의 엔트리 포인트 지정    main: &quot;./src/client/js/main.js&quot;,    something: &quot;./src/client/js/something.js&quot;,  },  mode: &quot;development&quot;,  watch: true,  output: {    // 각각을 이름 [name] (변수)으로 저장    filename: &quot;js/[name].js&quot;,    path: path.r..."
  },
  
  {
    "title": "Webpack Babel-Loader 사용법",
    "url": "/posts/2021-04-03-babel-loader/",
    "categories": "webpack",
    "tags": "webpack, javascript, babel",
    "date": "2021-04-03 00:00:00 +0800",
    





    "snippet": "npm install babel-loader -D{    test: /\\.js$/,    use: {        loader: &quot;babel-loader&quot;,        options: {            presets: [                [&quot;@babel/preset-env&quot;, { targets: &quot;defaults&quot; }],            ],        },    },}"
  },
  
  {
    "title": "Webpack 기본 사용법",
    "url": "/posts/2021-04-02-webpack-config/",
    "categories": "webpack",
    "tags": "webpack, javascript",
    "date": "2021-04-02 00:00:00 +0800",
    





    "snippet": "설치npm install webpack webpack-cli -D설정 파일 만들기const path = require(&quot;path&quot;);module.exports = {  entry: &quot;./src/client/js/main.js&quot;,  mode: &quot;development&quot;,  watch: true, // 자동으로 변화 감시  output: {    filename: &quot;main.js&quot;,    path: path.resolve(__dirname, &quot;asset..."
  },
  
  {
    "title": "Webpack이란?",
    "url": "/posts/2021-04-01-what-is-webpack/",
    "categories": "webpack",
    "tags": "webpack, gulp, javascript",
    "date": "2021-04-01 00:00:00 +0800",
    





    "snippet": "WebPack은 자바스크립트 애플리케이션의 정적 모듈 번들러 (Static Module Bundler)로, 규모가 있는 시스템에 존재할 수 있는 많은 자바스크립트 파일들을 하나의 파일로 관리하기 위해 사용된다.Bundle이란?  소프트웨어 및 일부 하드웨어와 함께 작동하는 데 필요한 모든 것을 포함하는 패키지  각각의 모듈들에 대해 의존성 관계를 파악한 하나 또는 여러 개의 그룹Module Bundler란?대부분의 프로그래밍 언어에서는 코드를 여러 개의 파일로 분할하고, 각각의 파일에 담겨있는 기능들을 사용하기 위해서 애플리케..."
  },
  
  {
    "title": "Express AWS S3를 사용한 파일 업로드 예제",
    "url": "/posts/2021-02-12-heroku/",
    "categories": "node, express",
    "tags": "node, aws, s3, express",
    "date": "2021-02-12 00:00:00 +0800",
    





    "snippet": "Bucket 생성AWS S3 Bucket 생성.IAM User 생성AWS_ID = 123123;AWS_SECRET = 123123;IAM -&amp;gt; User -&amp;gt; 새로운 유저 생성. 액세스 키, 비밀 키 복사 후 .env 파일에 (사실 개발 환경에서는 로컬에 저장하면 되고, Heroku에서만 AWS로 저장하면 되기 때문에 .env 파일에 저장할 필요는 없지만 테스트를 위해서) 환경 변수로 정의하고, 똑같은 이름으로 Heroku Config Vars도 설정한다.Servernpm install --save mu..."
  },
  
  {
    "title": "내가 사용하는 Commit · PR 규칙",
    "url": "/posts/2021-02-04-commit-convention/",
    "categories": "development",
    "tags": "convention, git, github",
    "date": "2021-02-04 00:00:00 +0800",
    





    "snippet": "Commit 규칙$ git commit -m &quot;Prefix: Message (#issue)&quot;  Prefix: Message 형식으로 작성한다.  접두사는 모두 소문자로 작성한다.  접두사와 콜론 (:)은 띄어쓰지 않는다.  콜론과 메시지는 한 칸 띄어쓴다.  관련된 이슈 번호는 맨 뒤에 괄호 (())안에 작성한다.  메시지와 이슈 번호는 한 칸 띄어쓴다.메시지는 반드시 영어일 필요가 없으며, 가장 명확하고 짧게 쓸 수 있는 방법으로 작성한다. 예를들어 a.txt라는 파일을 삭제 했다면, 그것에 대해 설명하는 ..."
  },
  
  {
    "title": "내가 사용하는 Git 브랜치 전략 (Branch Strategy)",
    "url": "/posts/2021-02-03-branch-strategy/",
    "categories": "development",
    "tags": "convention, git",
    "date": "2021-02-03 00:00:00 +0800",
    





    "snippet": "전략브랜치 전략은 Git Flow, GitHub Flow 등이 있고, 선택적으로 사용하면 된다. 내 경우 혼자 일한지 오래되었기 때문에 나름의 규칙을 만들어놓고 지켜가며 일하는데, 이 브랜치 전략 역시 규칙 중 하나에 해당한다. (아마도 어쩌다보니 2개가 섞여서 내 입맛에 맞게 된듯)main배포 가능한 상태만을 병합하는 브랜치. 혼자 개발할 때는 대부분 이 main 브랜치에 대한 역할만 확실하다면 (GitHub Flow에서 지향하는 것처럼) 딱히 문제가 생길 일이 별로 없다. 그래서 블로그처럼 단순한 개발 (관리)의 경우 그냥..."
  },
  
  {
    "title": "내가 사용하는 GitHub Issue 관리를 위한 Label 규칙",
    "url": "/posts/2021-02-02-issue-label/",
    "categories": "development",
    "tags": "convention, github",
    "date": "2021-02-02 00:00:00 +0800",
    





    "snippet": "GitHub에서 이슈를 (또는 PR)을 작성할 때 기본적으로 제공되는 레이블은 다음과 같다.            Label      Description                  bug      Something isn’t working              documentation      Improvements or additions to documentation              duplicate      This issue or pull request already exists              enh..."
  },
  
  {
    "title": "오랜만에 리마인드 해보는 클린 코드를 위한 기본 규칙",
    "url": "/posts/2021-02-01-clean-code/",
    "categories": "development",
    "tags": "convention",
    "date": "2021-02-01 00:00:00 +0800",
    





    "snippet": "Clean Code  주석을 최소화 할 수 있는 코드  코드 작성자가 아닌 사람도 금방 배울 수 있는 코드  나중에 다시 읽을 때 ‘읽기 위한 공부’를 위해서 Additianal Cost를 지불하지 않아도 되는 코드  미래의 내가 똑같은 코드를 작성해도 (코드의 내용은 달라질 수 있지만) 일정한 포맷을 유지하는 코드Naming  단수와 복수를 구분  상수는 모두 대문자로 작성  a, b 따위의 초성 퀴즈 금지  항상 전 세계 공통 (영어) 누가봐도 유추할 수 있도록  변수명과 클래스명에는 동사가 아니라 명사를 사용  함수명에는..."
  },
  
  {
    "title": "2021 프론트엔드 · 백엔드 호스팅 서비스와 CDN 서비스 정리",
    "url": "/posts/2021-01-23-hosting-services/",
    "categories": "development",
    "tags": "bookmark, cdn, hosting",
    "date": "2021-01-23 00:00:00 +0800",
    





    "snippet": "Front-End            Service      Description                  GitHub Pages      공개 저장소 호스팅 무료비공개 저장소에서의 호스팅은 유료 월 $4              Glitch      공개 저장소 호스팅 무료비공개 저장소에서의 호스팅은 유료 월 $8              Google Cloud Storage      사용한 만큼 후불 결제              AWS S3      사용한 만큼 후불 결제              Vercel      개인..."
  },
  
  {
    "title": "iTerm2 세팅 방법",
    "url": "/posts/2021-01-20-setup-mac-terminal-with-iterm2/",
    "categories": "development",
    "tags": "mac, terminal, iterm, setting",
    "date": "2021-01-20 00:00:00 +0800",
    





    "snippet": "iTerm2 설치와 설정가장 먼저 다음의 명령어로 homebrew를 이용해 iTerm2를 설치한다. 최신 버전이 아닌 다른 버전을 설치하고 싶거나, homebrew를 사용하지 않는다면 공식 홈페이지를 참고하자.$ brew install --cask iterm2테마 설치와 적용다음으로는 컬러 테마를 변경하기 위해서 iTerm2 Color Schemes에서 마음에 드는 테마를 골라 .itermcolors 파일을 다운로드 한다. 설치는 다운로드 한 파일을 더블 클릭하면 된다.이제 iTerm2를 실행하고 iTerm2 - Prefere..."
  },
  
  {
    "title": "타입스크립트 기초 토막 정리 #3 인터페이스",
    "url": "/posts/2020-12-21-typescript-interface/",
    "categories": "typescript",
    "tags": "typescript",
    "date": "2020-12-21 00:00:00 +0800",
    





    "snippet": "자바스크립트에서는 클래스를 인터페이스처럼 활용하기도 했지만, 타입스크립트는 그렇지 않다. 클래스와의 차이점은 이 글을 참고.interface Person {  name: string;  age: number;  gender: string;}// 인자가 Person과 같은지 확인function greeting(person: Person): void {  console.log(`${person.name}: ${person.age} years, ${person.gender}.`);}const obj = {  name: &quot;J..."
  },
  
  {
    "title": "타입스크립트 기초 토막 정리 #2 클래스",
    "url": "/posts/2020-12-20-typescript-class/",
    "categories": "typescript",
    "tags": "typescript",
    "date": "2020-12-20 00:00:00 +0800",
    





    "snippet": "자바스크립트의 클래스자바스크립트에서는 클래스가 가지고 있는 속성들에 대해 신경 쓸 필요가 별로 없다. 그냥 사용할 클래스 내용을 작성하기만 하면 된다. 자바스크립트에서 인터페이스가 필요할 때 (쓰고 싶을 때)는 클래스를 대신 사용할 수 있다.class Rectangle {  constructor(height, width) {    this.height = height;    this.width = width;  }  get area() {    return this.calcArea();  }  calcArea() {    re..."
  },
  
  {
    "title": "타입스크립트 기초 토막 정리 #1 타입 지정",
    "url": "/posts/2020-12-19-typescript-types/",
    "categories": "typescript",
    "tags": "typescript",
    "date": "2020-12-19 00:00:00 +0800",
    





    "snippet": "파라미터 타입 지정function greeting(name: string, age: number, gender: string) {  console.log(`${name}: ${age} years, ${gender}.`);}greeting(&quot;Jack&quot;, &quot;24&quot;, &quot;male&quot;);export {};타입스크립트에서는 파라미터의 타입을 위와 같이 지정할 수 있다. 위 코드를 컴파일하면 다음과 같은 에러가 발생한다.index.ts:5:18 - error TS2345: Argument..."
  },
  
  {
    "title": "타입스크립트를 사용하기 위한 기본 세팅 방법",
    "url": "/posts/2020-12-18-typescript-setting-up/",
    "categories": "typescript",
    "tags": "typescript, setting",
    "date": "2020-12-18 00:00:00 +0800",
    





    "snippet": "설치npm install -g typescript먼저 typescript를 Global로 설치한다. VS Code를 사용한다면, EsLint 확장을 설치한다. (TsLint 확장은 지원이 중단 되었기 때문에 더이상 사용되지 않는다.)설정{  &quot;compilerOptions&quot;: {    &quot;module&quot;: &quot;commonjs&quot;,    &quot;target&quot;: &quot;ES2015&quot;,    &quot;sourceMap&quot;: true  },  &quot;i..."
  },
  
  {
    "title": "Cookie · Session 기술의 이해",
    "url": "/posts/2020-12-11-sessions-cookies/",
    "categories": "web",
    "tags": "web, cookie, session",
    "date": "2020-12-11 00:00:00 +0800",
    





    "snippet": "Cookie와 Session을 사용하는 이유HTTP Protocol은 비연결성 (Connectionless)과 비상태성 (Stateless) 특징을 가지고 있다. 이 특징으로 인해 사용자가 요청할 때 마다 연결과 해제의 과정을 거치기 때문에 연결 상태를 유지하지 않고, 연결을 해지한 후에 상태 정보도 저장하지 않아 서버의 자원을 절약할 수 있다.하지만 이러한 특징으로 인해 사용자를 식별할 수 없어, 같은 사용자가 여러번 요청하더라도 매번 새로운 사용자로 인식한다는 단점이 존재하며, 이를 보완하기 위해 Cookie (이하 쿠키)..."
  },
  
  {
    "title": ".prettierrc, .eslintrc 작성법",
    "url": "/posts/2020-11-14-eslint-prettier/",
    "categories": "development",
    "tags": "linter, prettier, eslint",
    "date": "2020-11-14 00:00:00 +0800",
    





    "snippet": "Prettier{  &quot;arrowParens&quot;: &quot;always&quot;,  &quot;bracketSpacing&quot;: true,  &quot;endOfLine&quot;: &quot;auto&quot;,  &quot;printWidth&quot;: 80,  &quot;tabWidth&quot;: 4,  &quot;useTabs&quot;: false}.prettierrc 파일을 생성하고 위 코드 예제와 같이 원하는 설정을 작성한다. 설정을 적용하려면 파일을 저장하고 프로젝트 폴더를 재실행한다...."
  },
  
  {
    "title": "특정 단어로 시작하거나 끝나는 문자열을 검사하는 정규식 표현",
    "url": "/posts/2020-09-07-regexp-startswith-endwith/",
    "categories": "regexp",
    "tags": "regexp",
    "date": "2020-09-07 00:00:00 +0800",
    





    "snippet": "앵커 (Anchor)캐럿 기호인 다음 두 기호를 앵커 (Anchor)라고 한다. 이 두 개의 앵커를 사용해서 문자열이 특정 단어로 시작하거나, 끝나는지 여부를 검사하는 정규식 표현을 만들 수 있다.  ^ : 텍스트의 시작  $ : 텍스트의 끝특정 단어로 시작하는 문자열const string = &quot;Hello World!&quot;;/^Hello/는 문자열이 시작하고 바로 Hello가 나타난다는 뜻으로, 문자열이 Hello로 시작하는지 검사할 수 있다. 이를 대신해 자바스크립트의 문자열 메소드 startsWith()를 사..."
  },
  
  {
    "title": "React Hook이란?",
    "url": "/posts/2020-06-12-what-is-hook/",
    "categories": "react",
    "tags": "react, javascript",
    "date": "2020-06-12 00:00:00 +0800",
    





    "snippet": "함수 컴포넌트에서 state를 가질 수 있게 해준다. 참고예시class App extends React.Component {  state = {    count: 0,  };  add = () =&amp;gt; {    this.setState({ count: this.count + 1 });  };  render() {    const { count } = this.state;    return (      &amp;lt;div class=&quot;App&quot;&amp;gt;        &amp;lt;h1&amp;gt..."
  },
  
  {
    "title": "React 타입 검사를 위한 Prop-Types 사용법",
    "url": "/posts/2020-06-11-react-prop-types/",
    "categories": "react",
    "tags": "react, javascript",
    "date": "2020-06-11 00:00:00 +0800",
    





    "snippet": "타입 검사가 아주 중요하게 다뤄질 만큼 프로젝트 덩치가 커지면, 그냥 타입스크립트를 쓰는 것도 좋은 대안이다. 하지만, 어쩔 수 없이 자바스크립트로 프로젝트를 진행 해야 할 경우 prop-types를 사용하면 된다.npm install prop-types전달받은 Props가 의도한 Props인지 체크해주는 역할을 한다.import PropTypes from &quot;prop-types&quot;;// Componenetfunction Greeting({ name, age }) {  return (    &amp;lt;h1&a..."
  },
  
  {
    "title": "React 배열을 사용한 동적 컴포넌트 생성",
    "url": "/posts/2020-06-10-react-dynamic-component-generation/",
    "categories": "react",
    "tags": "react, javascript",
    "date": "2020-06-10 00:00:00 +0800",
    





    "snippet": "const family = [  {    name: &quot;John&quot;,    age: 24,  },  {    name: &quot;Edward&quot;,    age: 18,  },  {    name: &quot;Tim&quot;,    age: 20,  },];function renderMembers(member) {  return &amp;lt;Greeting name={member.name} age={member.age} /&amp;gt;;}function App() {  return (    &amp;..."
  },
  
  {
    "title": "React 컴포넌트의 라이프 사이클",
    "url": "/posts/2020-06-09-react-component-life-cycle/",
    "categories": "react",
    "tags": "react, javascript",
    "date": "2020-06-09 00:00:00 +0800",
    





    "snippet": "MountingMounting은 컴포넌트가 탄생하는 단계이며, 다음과 같은 순서로 새로운 컴포넌트가 생성된다.  constructor() : 자바스크립트에서 클래스를 만들 때 생성되는 생성자 함수.  static getDerivedStateFromProps()  render()  componentDidMount()class App extends React.Component {  state = {    count: 0,  };  constructor(props) {    super(props);    console.log(&qu..."
  },
  
  {
    "title": "React Routes 사이에 Props를 공유하는 방법",
    "url": "/posts/2020-06-08-react-sharing-props-between-routes/",
    "categories": "react",
    "tags": "react, javascript",
    "date": "2020-06-08 00:00:00 +0800",
    





    "snippet": "import React from &quot;react&quot;;function About(props) {  console.log(props);  return &amp;lt;h3&amp;gt;About this page: I build it!&amp;lt;/h3&amp;gt;;}export default About;위 코드 예제는 /about 경로로 이동했을 때 보여지는 About 컴포넌트이다. 인자로 props를 받고 있고, console.log()로 확인하고 있다. 이때 라우팅을 한 쪽에서는 아무것도 보내지 않고 있지만, ..."
  },
  
  {
    "title": "React HashRouter와 BrowserRouter의 차이점",
    "url": "/posts/2020-06-07-hashrouter-browserrouter/",
    "categories": "react",
    "tags": "react, javascript",
    "date": "2020-06-07 00:00:00 +0800",
    





    "snippet": "라우터의 종류  BrowserRouter  HashRouter  MemoryRouter  NativeRoter  StaticRouterHashRouter# 예 : abc.com/#/home  URL 앞에 해쉬 (#)가 붙는다.  검색 엔진이 읽지 못한다.  해쉬 히스토리 지원하지 않는다.  새로고침해도 에러가 나지 않는다.  정적인 페이지에 적합하다. (미리 저장된 페이지가 그대로 보여지는 페이지)  gh-pages를 사용할 때 좀 더 편하다.BrowserRouter  레거시 브라우저 (IE9 이하)에서는 사용할 수 없다.  ..."
  },
  
  {
    "title": "React Routing 기본 이해",
    "url": "/posts/2020-06-06-react-router-dom/",
    "categories": "react",
    "tags": "react, javascript",
    "date": "2020-06-06 00:00:00 +0800",
    





    "snippet": "npm install react-router-domimport React from &quot;react&quot;;import { HashRouter, Route } from &quot;react-router-dom&quot;;import Navigation from &quot;./components/Navigation&quot;;import About from &quot;./routes/About&quot;;import Home from &quot;./routes/Home&quot;;function App() {  retur..."
  },
  
  {
    "title": "React Styled-Component 현재 경로 메뉴 스타일 강조하기",
    "url": "/posts/2020-06-05-styled-componenets-withRouter/",
    "categories": "react, styled-component",
    "tags": "react, javascript, styled-component, css-in-js",
    "date": "2020-06-05 00:00:00 +0800",
    





    "snippet": "withRouter현재 경로는 라우터에서 사용하는 객체인 location 내부에 pathname으로 알 수 있다. 이 location 객체는 라우트가 아닌 컴포넌트에서 사용할 수 없는데, 이를 가능하게 만들기 위해서 withRouter라는 HoC를 사용한다.현재 경로 메뉴 강조하기import React from &quot;react&quot;;import { Link, withRouter } from &quot;react-router-dom&quot;;import styled from &quot;styled-components..."
  },
  
  {
    "title": "React Styled-Component 글로벌 공통 스타일 지정하기",
    "url": "/posts/2020-06-04-styled-components-createGlobalStyle/",
    "categories": "react, styled-component",
    "tags": "react, javascript, styled-component, css-in-js",
    "date": "2020-06-04 00:00:00 +0800",
    





    "snippet": "npm install styled-resetreset 파일 적용을 위해서 styled-reset를 설치한다.import { createGlobalStyle } from &quot;styled-components&quot;;import reset from &quot;styled-reset&quot;;const globalStyle = createGlobalStyle`    ${reset};    /* 공통 스타일 지정 */`;export default globalStyle;Components 폴더에 GlobalStyle.js 등..."
  },
  
  {
    "title": "React Container - Presenter 패턴",
    "url": "/posts/2020-06-03-react-container-presenter-pattern/",
    "categories": "react",
    "tags": "react, javascript",
    "date": "2020-06-03 00:00:00 +0800",
    





    "snippet": "React (이하 리액트)에서 Container - Presenter 패턴이란 데이터 처리 부분과 데이터 출력 (표현) 부분을 분리하여 개발 및 관리하는 디자인 패턴을 의미한다. 리액트 코드가 길어질 수록 컴포넌트 내부가 복잡해지기 때문에 유지보수 하기가 굉장히 번거로워 지는데, 이 디자인 패턴을 사용하면 데이터의 처리 부분과 출력 (표현)을 담당하는 부분을 나누어 작성하고 관리하기 때문에 코드의 가독성을 높일 수 있다.  Container : 데이터를 담당. 데이터와 상태 값을 가지고, API를 불러와서 모든 로직을 처리. ..."
  },
  
  {
    "title": "React 클래스 컴포넌트 state 사용하는 방법",
    "url": "/posts/2020-06-02-react-class-component-state/",
    "categories": "react",
    "tags": "react, javascript",
    "date": "2020-06-02 00:00:00 +0800",
    





    "snippet": "클래스 컴포넌트에서는 함수 컴포넌트에는 없는 state를 사용할 수 있다. state는 Object이며, 변경될 (변경할) 값을 다룬다.class App extends React.Component {  state = {    count: 0,  };}state는 클래스 컴포넌트 안에 state = {}; 형식으로 생성할 수 있다.state 사용class App extends React.Component {  state = {    count: 0,  };  render() {    return (      &amp;lt;div..."
  },
  
  {
    "title": "React 클래스 컴포넌트와 함수 컴포넌트의 차이점",
    "url": "/posts/2020-06-01-react-class-component/",
    "categories": "react",
    "tags": "react, javascript",
    "date": "2020-06-01 00:00:00 +0800",
    





    "snippet": "함수 컴포넌트function App() {  return (    &amp;lt;div className=&quot;App&quot;&amp;gt;      {members.map((member) =&amp;gt; {        return &amp;lt;Greeting name={member.name} age={member.age} /&amp;gt;;      })}    &amp;lt;/div&amp;gt;  );}함수 컴포넌트는 자체로 함수이기 때문에 뭔가를 리턴한다. 클래스 컴포넌트와는 달리 state를 가지고 있지 ..."
  },
  
  {
    "title": "React 컴포넌트 (Component)란?",
    "url": "/posts/2020-05-29-react-component/",
    "categories": "react",
    "tags": "react, javascript",
    "date": "2020-05-29 00:00:00 +0800",
    





    "snippet": "HTML을 반환하는 함수.function App() {  return &amp;lt;div className=&quot;App&quot;&amp;gt;Hello&amp;lt;/div&amp;gt;;}export default App;예시import React from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;import App from &quot;./App&quot;;ReactDOM.render(  &amp;lt;React.StrictMode&amp;gt;  ..."
  },
  
  {
    "title": "CSS 잠깐 보여지고 사라지는 Flash Message 애니메이션 예제",
    "url": "/posts/2020-05-14-flash-message/",
    "categories": "css",
    "tags": "css, animation",
    "date": "2020-05-14 00:00:00 +0800",
    





    "snippet": "사용자가 로그인하거나 로그아웃할 때 사이트 왼쪽 하단에서 잠깐 동안 보여지고 사라지는 플래시 메시지창.&amp;lt;div class=&quot;notification&quot;&amp;gt;hello&amp;lt;/div&amp;gt;.notification {  opacity: 0;  position: absolute;  bottom: 0px;  right: 50px;  border-radius: 50px;  background-color: white;  padding: 1em 2em;  text-align: center;..."
  },
  
  {
    "title": "CSS 천천히 사라지는 Fade Out 애니메이션 예제",
    "url": "/posts/2020-05-13-fade-out/",
    "categories": "css",
    "tags": "css, animation",
    "date": "2020-05-13 00:00:00 +0800",
    





    "snippet": "&amp;lt;div class=&quot;flash&quot;&amp;gt;&amp;lt;/div&amp;gt;.flash {  animation: goAway 0.5s ease-in-out forwards;  animation-delay: 2s;}@keyframes goAway {  from {    transform: none;    opacity: 1;  }  to {    transform: tanslateY(-50px);    opacity: 0;  }}"
  },
  
  {
    "title": "CSS 애니메이션 기본 사용법",
    "url": "/posts/2020-05-11-animation/",
    "categories": "css",
    "tags": "css, animation",
    "date": "2020-05-11 00:00:00 +0800",
    





    "snippet": "적용 원리  animation 속성과 하위 속성을 지정  애니메이션의 중간 상태를 @keyframes 규칙을 이용하여 기술@keyframes애니메이션의 중간 상태 (특정 시점에 Element가 어떻게 보여질지)를 표현하기 위해서는 @keyframes 규칙을 이용해서 2개 이상의 중간 상태를 기술한다.중간 상태가 전체 애니메이션에서 언제 등장할지는 % 수치 또는 from - to를 이용해 표현한다. 0%는 애니메이션이 시작된 시점을 의미하고, 100%는 애니메이션이 끝나는 시점을 의미하며, 최소한 두 시점 (시작과 끝)은 기술되..."
  },
  
  {
    "title": "Socket.io 사용자 로그인과 로그아웃 구현 예제",
    "url": "/posts/2020-05-10-socket-io-user-login-logout/",
    "categories": "node, socket-io",
    "tags": "node, socket-io, express, websocket, javascript",
    "date": "2020-05-10 00:00:00 +0800",
    





    "snippet": "Loginfunction loadNickname() {  const nickname = JSON.parse(localStorage.getItem(LS_NICKNAME));  if (nickname) {    loginUser(nickname);  } else {    setNickname();  }}페이지가 로드될 때, localStorage에 저장된 닉네임이 있는지 확인한다. 저장된 닉네임이 있다면 로그인 처리를 하고, 없다면 닉네임을 입력받는다.저장된 닉네임이 없는 경우function setNickname() {  gues..."
  },
  
  {
    "title": "Socket.io 소켓 관련 함수를 하나의 파일로 관리하기",
    "url": "/posts/2020-05-09-group-socket/",
    "categories": "node, socket-io",
    "tags": "node, socket-io, express, websocket, javascript",
    "date": "2020-05-09 00:00:00 +0800",
    





    "snippet": "// src/frontend/login.jsfunction login(nickname) {  // 서버에 연결되는 시점 =&amp;gt; 소켓이 생성되는 시점  const socket = io(&quot;/&quot;);  socket.emit(window.events.setNickname, { nickname });  initSocket(socket);}// src/frontend/socket.jsimport { enterUser, leaveUser } from &quot;./notifications&quot;;import ..."
  },
  
  {
    "title": "Socket.io 실시간 채팅 구현 예제 #2",
    "url": "/posts/2020-05-07-socket-io-chatting/",
    "categories": "node, socket-io",
    "tags": "node, socket-io, express, websocket, javascript",
    "date": "2020-05-07 00:00:00 +0800",
    





    "snippet": "설명은 주석으로 대신함.Frontend// src/frontend/chat.jsimport { getSocket } from &quot;./socket&quot;;const chat = document.querySelector(&quot;.chat&quot;);const messages = chat.querySelector(&quot;ul&quot;);const formMessage = chat.querySelector(&quot;form&quot;);export function newMessage({ message, nick..."
  },
  
  {
    "title": "Socket.io 실시간 채팅 구현 예제 #1",
    "url": "/posts/2020-05-06-socket-io-real-time-chat/",
    "categories": "node, socket-io",
    "tags": "node, socket-io, express, websocket, javascript",
    "date": "2020-05-06 00:00:00 +0800",
    





    "snippet": "설명은 주석으로 대신함.Server// 서버 연결시 새로운 소켓 생성// 서버는 모든 이벤트에 대해 열려 있음ioServer.on(&quot;connection&quot;, (socket) =&amp;gt; {  // newMessage 이벤트에 대해 듣고 있음  socket.on(&quot;newMessage&quot;, ({ message }) =&amp;gt; {    // 접속자를 제외한 모든 클라이언트에 messageNotication 이벤트를 발생시킴    socket.broadcast.emit(&quot;messa..."
  },
  
  {
    "title": "Socket.io 이벤트 컨트롤러 분리하기",
    "url": "/posts/2020-05-05-socket-io-controller/",
    "categories": "node, socket-io",
    "tags": "node, socket-io, express, websocket, javascript",
    "date": "2020-05-05 00:00:00 +0800",
    





    "snippet": "Serverconst PORT = 4000;const app = express();const server = app.listen(PORT, listenPort);const ioServer = socketIO(server);ioServer.on(&quot;connection&quot;, (socket) =&amp;gt; {  // 소켓의 정보가 유실되지 않도록 인자로 전달  socketController(socket);});ioServer는 모든 연결에 대해 (모든 소켓에 대해) 듣고 있다. 이때 위와 같이 내부에서 모든 이벤트..."
  },
  
  {
    "title": "Socket.io 이벤트와 객체를 하나의 파일로 관리 · 공유하기",
    "url": "/posts/2020-05-04-socket-io-share-object/",
    "categories": "node, socket-io",
    "tags": "node, socket-io, express, websocket, javascript",
    "date": "2020-05-04 00:00:00 +0800",
    





    "snippet": "이벤트를 하나의 객체로 관리하기// src/events.jsconst events = {  enterUser: &quot;enterUser&quot;,  logoutUser: &quot;logoutUser&quot;,};export default events;Socket.io의 이벤트를 한 번에 관리하기 위해서 위 코드 예제와 같이 events.js 파일을 만들고, 파일 내부에 객체를 만들어 export 한다. 이렇게 하면 이벤트 컨트롤러를 작성하는 부분과 이벤트를 감시하는 부분 모두 이벤트 이름을 하드 코딩 하지않고 객체로 ..."
  },
  
  {
    "title": "Socket.io 이벤트를 다루는 방법",
    "url": "/posts/2020-05-02-socket-io-events/",
    "categories": "node, socket-io",
    "tags": "node, socket-io, express, websocket, javascript",
    "date": "2020-05-02 00:00:00 +0800",
    





    "snippet": "이벤트의 동작과 처리  서버와 클라이언트는 이벤트를 듣고 있음.  이벤트 발생시 듣고 있던 서버 / 클라이언트가 반응.// ioServer는 모든 이벤트를 감시하고 있어야 함// connection 이벤트에 대해 듣고 있음// 새로운 연결이 생성되면 새로운 소켓이 생성 됨ioServer.on(&quot;connection&quot;, (socket) =&amp;gt; {  // 접속한 소켓을 제외한 모든 클라이언트에 enterUser 이벤트 전송  socket.broadcast.emit(&quot;enterUser&quot;)..."
  },
  
  {
    "title": "Socket.io 동작 이해",
    "url": "/posts/2020-05-01-how-to-work-socket-io/",
    "categories": "node, socket-io",
    "tags": "node, socket-io, express, websocket, http, javascript",
    "date": "2020-05-01 00:00:00 +0800",
    





    "snippet": "Socket.io를 사용한다는 것은 Express 서버 위에 Socket.io (WebSocket) 서버를 올린다는 의미이다. 전통적인 (?) 방식에서, 2개의 서버가 같은 포트에서 동작하게 할 수 없지만, WebSocket과 HTTP는 같은 공생이 가능하다.Express 서버 위에 Socket.io 서버를 올리는 방법import express from &quot;express&quot;;import socketIO from &quot;socket.io&quot;;const PORT = 4000;const app = expre..."
  },
  
  {
    "title": "모던 자바스크립트와 ES6 #11 async · await",
    "url": "/posts/2020-04-19-es6-syntax-21-async-await/",
    "categories": "javascript",
    "tags": "javascript, es6",
    "date": "2020-04-19 00:00:00 +0800",
    





    "snippet": "ES5까지의 비동기 처리는 에러 처리가 힘들고 콜백 지옥같은 문제가 있어서, ES6에서는 Promise를 도입했다. 하지만 Promise를 사용하더라도 여전히 코드가 길어지는 것은 해결할 수 없었고, 이러한 점들을 보완하기 위해서 ES8에서 asnyc와 await이 도입되었다.  async와 await을 비동기 처리에서 절대적으로 사용해야하는 것은 아니다. 콜백의 Depth가 얕은 경우에는 그냥 Promise를 사용하는것이 더 간결한 코드 작성법이 될 때도 있다.(async function func() {  await msg(..."
  },
  
  {
    "title": "모던 자바스크립트와 ES6 #10 Generator",
    "url": "/posts/2020-04-19-es6-syntax-20-generator/",
    "categories": "javascript",
    "tags": "javascript, es6",
    "date": "2020-04-19 00:00:00 +0800",
    





    "snippet": "Generator는 Generator Function의 리턴 값으로, Iterable Protocol과 Iterator Protocol을 따르는 객체이다. 이때 Generator Function은 함수를 실행하면 내부에 정의된 처리를 함수의 끝까지 한 번에 실행하는 일반 함수와 달리, yield와 next() 등을 사용해 특정 시점에 멈출 수도 있고, 다시 시작될 수도 있으며, 상황에 따라 여러 값을 리턴할 수도 있는 함수이다.function* genFunction() {  yield 100;  yield 200;  yield..."
  },
  
  {
    "title": "모던 자바스크립트와 ES6 #9 Promise",
    "url": "/posts/2020-04-19-es6-syntax-19-promise/",
    "categories": "javascript",
    "tags": "javascript, es6",
    "date": "2020-04-19 00:00:00 +0800",
    





    "snippet": "자바스크립트에서는 비동기 처리를 위해 일반적으로 콜백 함수를 사용한다. 하지만 기존의 콜백 패턴이 굉장히 지저분했고 예외 처리가 어려웠기 때문에, 여러 개의 비동기 처리를 한 번에 처리하려면 콜백 지옥이 열리곤 했다.first(function (a) {  second(function (b) {    third(function (c) {      fourth(function (d) {        // codes ...      });    });  });});이러한 문제점을 보완하기 위해서 ES6에서는 Promise라는 개념을..."
  },
  
  {
    "title": "모던 자바스크립트와 ES6 #8 Module",
    "url": "/posts/2020-04-19-es6-syntax-18-module/",
    "categories": "javascript",
    "tags": "javascript, es6",
    "date": "2020-04-19 00:00:00 +0800",
    





    "snippet": "대부분의 프로그래밍 언어는 각자의 모듈 기능을 가지고 있다. 예를 들어 C언어의 경우 #include를 사용해 외부의 모듈을 가져온다. 클라이언트 사이드의 자바스크립트의 경우, &amp;lt;script&amp;gt; 태그를 사용해서 외부의 모듈 (스크립트 파일)을 가져올 수 있다. 하지만 이 경우 파일 단위로 독자적인 Scope를 가지는 것이 아니라 하나의 전역 객체를 공유한다는 특징이 있다. 즉, 이렇게 &amp;lt;script&amp;gt; 태그로 모듈을 가져오는 경우 모듈화를 구현할 수는 없다.  서버 사이드 자바스크..."
  },
  
  {
    "title": "모던 자바스크립트와 ES6 #7 Destructuring Assignment",
    "url": "/posts/2020-04-19-es6-syntax-17-destructuring/",
    "categories": "javascript",
    "tags": "javascript, es6",
    "date": "2020-04-19 00:00:00 +0800",
    





    "snippet": "Destructuring Assignment Syntax는 배열이나 객체를 Destructuring (비구조화)해서 각각의 요소를 개별적인 변수에 할당하는 것을 의미하며, 일반적으로 구조화된 배열이나 객체에서 특정 값만을 꺼내 변수에 할당하거나 리턴하기 위해 사용된다.  추천 글 : Destructuring Assignment - MDNArray Destructuringarr에 들어있는 요소를 각각의 변수에 할당하고자 하는 경우를 가정해보자.var arr = [&quot;John&quot;, &quot;Thomas&quot;,..."
  },
  
  {
    "title": "모던 자바스크립트와 ES6 #6 Enhanced Object Literals",
    "url": "/posts/2020-04-19-es6-syntax-16-object-initailizer/",
    "categories": "javascript",
    "tags": "javascript, es6",
    "date": "2020-04-19 00:00:00 +0800",
    





    "snippet": "ES6에서는 향상된 객체의 Literal을 제공한다. 이는 ES5까지의 객체 정의 방식을 개선한 문법을 의미하며, 객체를 정의하거나 객체 내 메소드를 정의하는 등 자주 사용되는 문법들을 좀 더 간결하게 사용할 수 있다.Property ShorthandES6에서는 Props 값으로 변수를 사용할 때, Property 이름을 생략할 수 있는 축약 표현을 제공한다.const name = &quot;John&quot;;const age = 20;const obj = {  name,  age,};console.log(obj);Metho..."
  },
  
  {
    "title": "모던 자바스크립트와 ES6 #5 Spread Syntax",
    "url": "/posts/2020-04-19-es6-syntax-15-spread/",
    "categories": "javascript",
    "tags": "javascript, es6",
    "date": "2020-04-19 00:00:00 +0800",
    





    "snippet": "Spread Syntax (...)는 점 뒤에 오는 대상을 개별 요소로 분리한다. 이때 대상은 Iterable 해야 한다.const arr = [1, 2, 3];console.log(...arr, 4, 5);이를 응용해 배열을 파라미터로 함수에 전달하고자 할 때, 모든 요소를 분리해서 순차적으로 전달할 수 있다.function sum(a, b, c) {  return a + b + c;}const arr = [1, 2, 3];console.log(sum(...arr));사용 예시다음 코드는 arr1에 arr2의 각각의 요소를 ..."
  },
  
  {
    "title": "모던 자바스크립트와 ES6 #4 Default · Rest Parameter",
    "url": "/posts/2020-04-19-es6-syntax-14-default-rest-parameter/",
    "categories": "javascript",
    "tags": "javascript, es6",
    "date": "2020-04-19 00:00:00 +0800",
    





    "snippet": "Default Parameter Value자바스크립트에서는 함수를 호출할 때 요구되는 파라미터의 개수가 부족한 경우에도 에러가 발생하지 않는다. 예를 들어 다음의 경우를 가정해보자.function sum(a, b) {  return a + b;}console.log(sum(10));sum() 함수는 2개의 아규먼트를 사용하게끔 정의되어 있지만, 호출할 때 하나의 파라미터만 전달해도 에러가 발생하지 않는다. 즉, 함수가 파라미터 개수나 아규먼트 개수를 체크하지 않는다. 이렇게 아규먼트가 부족한 경우에 그 값은 undefined이..."
  },
  
  {
    "title": "모던 자바스크립트와 ES6 #3 Arrow Function",
    "url": "/posts/2020-04-19-es6-syntax-13-arrow-function/",
    "categories": "javascript",
    "tags": "javascript, es6",
    "date": "2020-04-19 00:00:00 +0800",
    





    "snippet": "Arrow Function (이하 화살표 함수)는 ES6에서 도입된, function 키워드를 사용하지 않아도 =&amp;gt; 화살표를 사용함으로써 보다 간단하게 함수를 선언할 수 있는 문법이다. 화살표 함수의 사용법은 매우 간단하지만, 다음과 같은 몇 가지 규칙이 있다.// 1. 아규먼트가 없을 경우 () 괄호 생략 불가() =&amp;gt; {};// 2. 아규먼트가 한 개일 때는 괄호를 생략해도 되지만, 2개 이상이면 괄호를 생략할 수 없음(a, b) =&amp;gt; {};// 3. 함수의 몸체가 Single Line..."
  },
  
  {
    "title": "모던 자바스크립트와 ES6 #2 Template Literals",
    "url": "/posts/2020-04-19-es6-syntax-12-template-literal/",
    "categories": "javascript",
    "tags": "javascript, es6",
    "date": "2020-04-19 00:00:00 +0800",
    





    "snippet": "ES5까지, 일반 텍스트와 변수를 하나의 문자열로 사용하려면 다음과 같이 했어야 했다.var a = 1;var b = 2;console.log(&quot;a is &quot; + a + &quot; and b is &quot; + b);알다시피 이런 방식은 귀찮다. 단호하게 귀찮다.const a = 1;const b = 2;console.log(`a is ${a} and b is ${b}`);ES6에서는 새로운 문자열 표기법인 Backtick을 사용할 수 있게 되었는데, 이 문자열로 감싼 내부에는 위 코드와 같이 변수를 직접적..."
  },
  
  {
    "title": "모던 자바스크립트와 ES6 #1 var · let · const",
    "url": "/posts/2020-04-19-es6-syntax-11-let-const/",
    "categories": "javascript",
    "tags": "javascript, es6",
    "date": "2020-04-19 00:00:00 +0800",
    





    "snippet": "var의 문제점ES5까지의 자바스크립트에서는 변수를 선언할 때 var 키워드를 사용했다. (물론 지금도 사용할 수 있지만 그때는 유일했다.) var 키워드는 특성상 문제를 야기할 가능성이 높았는데, 그 특성에 대한 내용은 다음과 같다.var a = 1;var b = 2;console.log(a); // 1console.log(b); // 2{  var a = 2;  var b = 3;}console.log(a); // 2console.log(b); // 3첫 번째로, 변수 중복 선언이 허용된다. 즉, 실수로 a라는 변수를 두 ..."
  },
  
  {
    "title": "자바스크립트 레벨업을 위한 주요 개념 #4 Higher Order Function",
    "url": "/posts/2020-04-18-js-level-up-4-higher-order-function/",
    "categories": "javascript",
    "tags": "javascript, hof",
    "date": "2020-04-18 00:00:00 +0800",
    





    "snippet": "Higher Order Function (HOF, 고차 함수)는 함수를 리턴하거나 함수를 파라미터로 전달받는 함수를 의미하며, 넘겨받은 함수를 호출하거나 클로저로 리턴하는 역할을 한다. 이게 가능한 이유는 자바스크립트의 함수가 First Class이기 때문인데, 더 자세한 내용은 MDN의 First Class Function 문서를 참고하자.이러한 고차 함수를 사용하는 이유는 함수형 프로그래밍 지향을 위해서, 데이터가 Mutate 되는 것을 최대한 피하고자 하기 때문이다. 즉, 함수형 프로그래밍은 Pure Function + ..."
  },
  
  {
    "title": "자바스크립트 레벨업을 위한 주요 개념 #3 this",
    "url": "/posts/2020-04-18-js-level-up-3-function-this-bind/",
    "categories": "javascript",
    "tags": "javascript, this",
    "date": "2020-04-18 00:00:00 +0800",
    





    "snippet": "자바스크립트에서는 어떤 함수가 호출될 때 전달되는 아규먼트 말고도 arguments라는 객체와 this가 은밀하게 (?) 전달되고 있다. this는 아마도 Java를 배워본적 있는 사람이라면 꽤 낯이 익는 친구일 것이다. 하지만 이때 this는 Java의 this와는 개념적으로 다른데, Java에서는 자기 자신의 Reference를 가르키는 변수로써 사용되지만, 자바스크립트에서는 함수를 호출하는 방식에 따라 this에 바인딩되는 객체가 달라진다.함수 호출 방식에 따른 this 바인딩자바스크립트에서 Lexical Scope는 함..."
  },
  
  {
    "title": "자바스크립트 레벨업을 위한 주요 개념 #2 Closure",
    "url": "/posts/2020-04-18-js-level-up-2-closure/",
    "categories": "javascript",
    "tags": "javascript, closure",
    "date": "2020-04-18 00:00:00 +0800",
    





    "snippet": "Closure (이하 클로저)는 자바스크립트에 한정되는 개념은 아니고, Functional Programming Language에서 다루는 주요한 특성 중 하나이다. 이 개념은 리턴된 함수가 리턴되기 전에 가진 Scope를 리턴된 다음에도 접근할 수 있는 함수를 의미한다. 즉, 클로저는 자기 자신이 생성될 때의 Lexical Environment를 기억하고 접근할 수 있는 함수라고 정의할 수 있다.function first() {  const greating = &quot;Hello World!&quot;;  const sec..."
  },
  
  {
    "title": "자바스크립트 레벨업을 위한 주요 개념 #1 Scope와 Scope Chain",
    "url": "/posts/2020-04-18-js-level-up-1-scope-chain/",
    "categories": "javascript",
    "tags": "javascript, scope",
    "date": "2020-04-18 00:00:00 +0800",
    





    "snippet": "변수나 함수는 각각의 유효한 Scope를 가지고 있다. Block Level Scope란 하나의 블록 {} 내부에서 선언된 변수는 해당 블록 내부에서만 유효하다는 규칙이며, Function Level Scope의 경우 함수 내부에서 선언된 변수는 함수 내부에서만 유효하다는 규칙이다.Lexical Scope자바스크립트의 Scope에 대해 좀 더 깊이 이해하기 위해 알아야 할 또 하나의 개념은 Lexical Scope (Static Scope)라는 규칙이다. Lexical Scope는 코드가 작성된 문맥상에서 결정되는 Scope로..."
  },
  
  {
    "title": "뷰포트 사이즈 단위 vh · vw · vmin · vmax 정리",
    "url": "/posts/2020-03-20-vh-vw-vmin-vmax/",
    "categories": "css",
    "tags": "css, animation",
    "date": "2020-03-20 00:00:00 +0800",
    





    "snippet": "vh · vwvh (Vertical Height)과 vw (Vertical Width) 단위는 뷰포트 높이 및 너비에 맞게 타겟 요소의 크기를 지정하고자 할 때 사용된다.body {  height: 100vh;}vh 요소는 높이 값의 1 / 100 단위이다. 즉, 뷰포트 높이 값이 1000px일 때 1vh는 10px이 되기 때문에, 100vh는 뷰포트 (브라우저 높이 값)의 100%에 해당된다. (vw의 경우에도 세로가 아니라 가로를 의미하는 것 외에는 동일하다.)vmin · vmaxvh와 vw 단위가 뷰포트의 높이 및 너비 ..."
  },
  
  {
    "title": "GitHub 저장소에서 파일 삭제하는 방법",
    "url": "/posts/2020-03-12-github-remove-file/",
    "categories": "git",
    "tags": "git, github",
    "date": "2020-03-12 00:00:00 +0800",
    





    "snippet": "GitHub에 파일 잘못올린 경우 다음과 같은 흐름으로 작업하여, 이미 원격 저장소에 올라간 파일을 삭제할 수 있다.  .gitignore 작성  원격 저장소에서 파일 삭제  원격 저장소에 적용원격 저장소에서 파일 삭제# 원격 저장소의 index.html 파일 삭제git rm --cached index.html# src/style.css 파일 삭제git rm --cached src/style.css# src 폴더 하위 모두 삭제git rm --cached -r src/위 명령어로 원격 저장소에 잘못 올라간 파일만 삭제한다. 이..."
  },
  
  {
    "title": "GitHub 여러 개의 Issue 한 번에 처리 (Close)하는 방법",
    "url": "/posts/2020-03-11-github-more-than-two-issue/",
    "categories": "git",
    "tags": "git, github",
    "date": "2020-03-11 00:00:00 +0800",
    





    "snippet": "git checkout -b &quot;issue-11&quot;이슈 해결을 위한 브랜치를 생성한다.git add .git commit -m &quot;Edit Documents (#12, #14)&quot;해당 브랜치에서 작업 후, add 및 commit 하고, Pull Request를 보내기 위해 Upstream으로 push 한다.- Close #12- Close #14Pull Request Comment에 해결된 이슈들을 키워드와 함께 작성한다. close 외에도 자동 이슈 처리를 위해서 사용할 수 있는 키워드는 다음과 ..."
  },
  
  {
    "title": "GitHub Issue 생성과 Pull Request 처리 방법",
    "url": "/posts/2020-03-10-github-issue-pull-request/",
    "categories": "git",
    "tags": "git, github",
    "date": "2020-03-10 00:00:00 +0800",
    





    "snippet": "이슈 생성과 처리의 흐름  Issue 생성  Branch 생성  Pull Request  Merge (Issue 처리)이슈 생성시 추가할 수 있는 항목  Assignees : 이슈 담당자  Labels : 카테고리  Milestone : 소속 파트 (예 : Version 1.0.0)Branch 생성# Branch 생성 후 Checkoutgit checkout -b issue-1이슈 처리를 위한 브랜치 생성.Pull Requestgit add .git commit -m &quot;Edit README.md (#12)&quot;작..."
  },
  
  {
    "title": "Git 상태 및 파일 복원을 위한 reset · revert · checkout 사용법",
    "url": "/posts/2020-03-08-git-revert-reset-checkout/",
    "categories": "git",
    "tags": "git",
    "date": "2020-03-08 00:00:00 +0800",
    





    "snippet": "상태 복원복원은 현재 파일을 특정한 시점의 파일 상태로 변경하는 작업을 의미한다. 이와 같은 복원을 위해 사용되는 대표적인 명령어들은 다음과 같다.  reset  revert  checkoutresetreset은 Staged (Tracked) 상태의 파일이나 커밋된 파일을 취소할 때 (이전 상태로 되돌릴 때) 사용되며, 커밋되지 않는다. (커밋되지 않기 때문에 push를 reset으로 취소했다가 다시 하려면 반드시 다시 커밋 해야 한다.)  add, commit, push 취소하기특징reset은 진행된 커밋 이전의 커밋으로 H..."
  },
  
  {
    "title": "Git Add · Commit · Push 취소 방법",
    "url": "/posts/2020-03-07-git-cancle-add-commit-push/",
    "categories": "git",
    "tags": "git, github",
    "date": "2020-03-07 00:00:00 +0800",
    





    "snippet": "git add 취소git add 명령을 취소한다는 것은, Staging Area에 있는 Tracked 파일을 Untracked (Unstage) 상태로 변경하는 것을 의미한다.# git add 한 파일 전체 취소$ git reset HEAD# 특정 파일만 취소$ git reset HEAD index.htmlcommit message 변경$ git commit --amend &quot;Message&quot;git commit 취소# commit 목록 확인$ git log$ git reset --soft HEAD^위 명령어는 커..."
  },
  
  {
    "title": "Git Branch 분기와 병합 예제 (--no--ff 사용법)",
    "url": "/posts/2020-03-04-git-branch-strategy/",
    "categories": "git",
    "tags": "git",
    "date": "2020-03-04 00:00:00 +0800",
    





    "snippet": "로그인 기능을 개발하는 과정을 가정해보자.# -b : 브랜치 생성# git checkout -b 생성할-브랜치 베이스-브랜치git checkout -b feature/login develop로그인 기능 개발을 위해 develop 브랜치에서 분기하는 feature/login 브랜치를 생성하고, 작업 브랜치를 feature/login 브랜치로 변경한다.git add .git commit -m &quot;feat: 로그인 기능 추가&quot;# develop 브랜치로 작업 브랜치 변경git checkout develop# featu..."
  },
  
  {
    "title": "Git Branch 관련 명령어 정리",
    "url": "/posts/2020-03-03-git-branch-commands/",
    "categories": "git",
    "tags": "git",
    "date": "2020-03-03 00:00:00 +0800",
    





    "snippet": "브랜치 확인# 브랜치 확인$ git branch# 브랜치 상세 정보까지 확인$ git branch -v브랜치 상태 확인# Merged 상태 브랜치 확인$ git branch --merged# Merged 되지 않은 브랜치 확인$ git branch --no-merged브랜치 생성$ git branch newBranch baseBranch브랜치 삭제$ git branch -d newBranch브랜치 이동$ git checkout newBranch브랜치 생성과 이동 숏컷$ git checkout -b newBranch baseBr..."
  },
  
  {
    "title": "Git Branch 기본 이해",
    "url": "/posts/2020-03-02-git-branch/",
    "categories": "git",
    "tags": "git",
    "date": "2020-03-02 00:00:00 +0800",
    





    "snippet": "Branch  버전 관리 시스템의 기본  Origin 코드와 별개로 독립된 개발을 진행하기 위해 사용맨 처음 커밋을 할 때, Git은 master (main)라는 이름을 가진 브랜치를 만들고 자동으로 가장 마지막 커밋을 가리키게 (포인터같이) 한다. 다음과 같은 상황을 가정해보자.  최초 커밋  develop이라는 브랜치 생성이때 새로 만든 브랜치 develop도 마지막 커밋을 가리킨다.HEADGit에서 현재 작업 중인 브랜치를 구분할 수 있는 것은 HEAD라는 일종의 포인터가 있기 때문이다. HEAD는 로컬에서 지금 작업하고..."
  },
  
  {
    "title": "GitHub Release 방법",
    "url": "/posts/2020-03-01-github-release/",
    "categories": "git",
    "tags": "git, github",
    "date": "2020-03-01 00:00:00 +0800",
    





    "snippet": "새로운 버전 릴리즈하는 방법릴리즈란 개발 중인 프로젝트가 배포 준비가 되었을 때 (Alpha / Beta / Major) 패키지를 배포하는 것을 의미한다. GitHub에서 릴리즈하기 위해서는 저장소 페이지의 사이드바에서 Create a new release 버튼을 클릭하고, 다음을 참조하여 항목을 채운다.Tag Version  v1.0  v2.3.4  v0.2-alpha  v5.9-betaRelease Title  Version 1.0.2  Something App v1.0  Hello World v2.0-alpha  Show..."
  },
  
  {
    "title": "Git 버전 관리의 Flow 이해",
    "url": "/posts/2020-03-01-git-flow/",
    "categories": "git",
    "tags": "git",
    "date": "2020-03-01 00:00:00 +0800",
    





    "snippet": "Git 작업 흐름Git은 파일을 세 가지 상태로 관리한다.  Commited  Modified  StagedCommited란 데이터 (파일)가 로컬 저장소에 저장된 상태를 의미하고, Modified는 파일을 수정했지만 아직 Staging Area에 추가하지 않은 상태를 의미하며, Staged는 수정한 파일을 Staging Area에 추가한 상태를 의미한다.Staging AreaStaging Area는 곧 커밋할 파일에 대한 정보를 저장한다. 수정한 파일은 git add 명령을 사용해 Staging 상태로 만들 수 있으며, gi..."
  },
  
  {
    "title": "Git Commit 기본 이해",
    "url": "/posts/2020-03-01-git-commit/",
    "categories": "git",
    "tags": "git",
    "date": "2020-03-01 00:00:00 +0800",
    





    "snippet": "Commit  작업에 이력을 기록해서 저장소로 올리는 것  Staging Area에 있는 Tracked 파일들을 저장소에 저장즉, git add 한 파일은 버전 관리되고 있는 파일 (Tracked)git commit$ git add .$ git commit -m &quot;Message&quot;# Shortcut: git commit -am &quot;Message&quot;git diff# Untracked 파일의 변경사항을 보여줌$ git diff# Tracked (커밋 대기) 파일의 변경사항을 보여줌$ git diff ..."
  },
  
  {
    "title": "navigator.geolocation 동작하지 않는 경우 해결 방법",
    "url": "/posts/2020-01-07-error-report-chrome-navigator-geolocation/",
    "categories": "javascript",
    "tags": "javascript, error, chrome, https, localhost, navigator, geolocation",
    "date": "2020-01-07 00:00:00 +0800",
    





    "snippet": "증상navigator.geolocation.getCurrentPosition() 메소드 동작하지 않는 경우. (정확히는 동작하지 않는 것처럼 보임.) 웹 페이지가 로드되면 위치 정보 사용을 묻는 팝업은 정상적으로 뜨고, 취소를 눌렀을 때 errorCallBack은 동작하지만 successCallBack은 내부 로직은 동작하지 않는 경우.원인 분석우선 errorCallBack 함수는 동작한다는 점에서, 메소드가 아예 동작하지 않는 것은 아니고 위치 정보 사용 허용을 눌렀을 때 successCallBack 함수가 실행은 되지만 위..."
  }
  
]

